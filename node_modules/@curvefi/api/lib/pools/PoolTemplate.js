"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PoolTemplate = void 0;
var ethers_1 = require("ethers");
var bignumber_js_1 = __importDefault(require("bignumber.js"));
var external_api_1 = require("../external-api");
var utils_1 = require("../utils");
var curve_1 = require("../curve");
var PoolTemplate = /** @class */ (function () {
    function PoolTemplate(id) {
        var _this = this;
        this.statsParameters = function () { return __awaiter(_this, void 0, void 0, function () {
            var multicallContract, calls, additionalCalls, _a, _virtualPrice, _fee, _adminFee, _A, _gamma, _c, virtualPrice, fee, adminFee, A, gamma, A_PRECISION, _d, _future_A, _initial_A, _future_A_time, _initial_A_time, _e, future_A, initial_A, future_A_time, initial_A_time;
            return __generator(this, function (_f) {
                switch (_f.label) {
                    case 0:
                        multicallContract = curve_1.curve.contracts[this.address].multicallContract;
                        calls = [
                            multicallContract.get_virtual_price(),
                            multicallContract.fee(),
                            multicallContract.admin_fee(),
                            multicallContract.A(),
                        ];
                        if (this.isCrypto)
                            calls.push(multicallContract.gamma());
                        additionalCalls = this.isCrypto ? [] : [multicallContract.future_A()];
                        if ('initial_A' in multicallContract) {
                            additionalCalls.push(multicallContract.initial_A(), multicallContract.future_A_time(), multicallContract.initial_A_time());
                        }
                        return [4 /*yield*/, curve_1.curve.multicallProvider.all(calls)];
                    case 1:
                        _a = _f.sent(), _virtualPrice = _a[0], _fee = _a[1], _adminFee = _a[2], _A = _a[3], _gamma = _a[4];
                        _c = [
                            ethers_1.ethers.utils.formatUnits(_virtualPrice),
                            ethers_1.ethers.utils.formatUnits(_fee, 8),
                            ethers_1.ethers.utils.formatUnits(_adminFee.mul(_fee)),
                            ethers_1.ethers.utils.formatUnits(_A, 0),
                            _gamma ? ethers_1.ethers.utils.formatUnits(_gamma) : _gamma,
                        ], virtualPrice = _c[0], fee = _c[1], adminFee = _c[2], A = _c[3], gamma = _c[4];
                        A_PRECISION = curve_1.curve.chainId === 1 && ['compound', 'usdt', 'y', 'busd', 'susd', 'pax', 'ren', 'sbtc', 'hbtc', '3pool'].includes(this.id) ? 1 : 100;
                        return [4 /*yield*/, curve_1.curve.multicallProvider.all(additionalCalls)];
                    case 2:
                        _d = _f.sent(), _future_A = _d[0], _initial_A = _d[1], _future_A_time = _d[2], _initial_A_time = _d[3];
                        _e = [
                            _future_A ? String(Number(ethers_1.ethers.utils.formatUnits(_future_A, 0)) / A_PRECISION) : undefined,
                            _initial_A ? String(Number(ethers_1.ethers.utils.formatUnits(_initial_A, 0)) / A_PRECISION) : undefined,
                            _future_A_time ? Number(ethers_1.ethers.utils.formatUnits(_future_A_time, 0)) * 1000 : undefined,
                            _initial_A_time ? Number(ethers_1.ethers.utils.formatUnits(_initial_A_time, 0)) * 1000 : undefined,
                        ], future_A = _e[0], initial_A = _e[1], future_A_time = _e[2], initial_A_time = _e[3];
                        return [2 /*return*/, { virtualPrice: virtualPrice, fee: fee, adminFee: adminFee, A: A, future_A: future_A, initial_A: initial_A, future_A_time: future_A_time, initial_A_time: initial_A_time, gamma: gamma }];
                }
            });
        }); };
        this.statsTotalLiquidity = function (useApi) {
            if (useApi === void 0) { useApi = true; }
            return __awaiter(_this, void 0, void 0, function () {
                var network, poolType, poolsData, totalLiquidity_1, balances, promises, _i, _a, addr, prices, totalLiquidity;
                var _this = this;
                return __generator(this, function (_c) {
                    switch (_c.label) {
                        case 0:
                            if (!useApi) return [3 /*break*/, 2];
                            network = curve_1.curve.chainId === 137 ? "polygon" : "ethereum";
                            poolType = !this.isFactory && !this.isCrypto ? "main" :
                                !this.isFactory ? "crypto" :
                                    !(this.isCrypto && this.isFactory) ? "factory" :
                                        "factory-crypto";
                            return [4 /*yield*/, (0, external_api_1._getPoolsFromApi)(network, poolType)];
                        case 1:
                            poolsData = (_c.sent()).poolData;
                            try {
                                totalLiquidity_1 = poolsData.filter(function (data) { return data.address.toLowerCase() === _this.address.toLowerCase(); })[0].usdTotal;
                                return [2 /*return*/, String(totalLiquidity_1)];
                            }
                            catch (err) {
                                console.log(err.message);
                            }
                            _c.label = 2;
                        case 2: return [4 /*yield*/, this.statsUnderlyingBalances()];
                        case 3:
                            balances = _c.sent();
                            promises = [];
                            for (_i = 0, _a = this.underlyingCoinAddresses; _i < _a.length; _i++) {
                                addr = _a[_i];
                                promises.push((0, utils_1._getUsdRate)(addr));
                            }
                            return [4 /*yield*/, Promise.all(promises)];
                        case 4:
                            prices = _c.sent();
                            totalLiquidity = balances.reduce(function (liquidity, b, i) { return liquidity + (Number(b) * prices[i]); }, 0);
                            return [2 /*return*/, totalLiquidity.toFixed(8)];
                    }
                });
            });
        };
        this.statsVolume = function () { return __awaiter(_this, void 0, void 0, function () {
            var network, poolsData, poolData;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        network = curve_1.curve.chainId === 137 ? "polygon" : "ethereum";
                        return [4 /*yield*/, (0, external_api_1._getSubgraphData)(network)];
                    case 1:
                        poolsData = (_a.sent());
                        poolData = poolsData.find(function (d) { return d.address.toLowerCase() === _this.address; });
                        if (!poolData)
                            throw Error("Can't get base APY for ".concat(this.name, " (id: ").concat(this.id, ")"));
                        return [2 /*return*/, poolData.volumeUSD.toString()];
                }
            });
        }); };
        this.statsBaseApy = function () { return __awaiter(_this, void 0, void 0, function () {
            var network, poolsData, poolData;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        network = curve_1.curve.chainId === 137 ? "polygon" : "ethereum";
                        return [4 /*yield*/, (0, external_api_1._getSubgraphData)(network)];
                    case 1:
                        poolsData = (_a.sent());
                        poolData = poolsData.find(function (d) { return d.address.toLowerCase() === _this.address; });
                        if (!poolData)
                            throw Error("Can't get base APY for ".concat(this.name, " (id: ").concat(this.id, ")"));
                        return [2 /*return*/, {
                                day: poolData.latestDailyApy.toString(),
                                week: poolData.latestWeeklyApy.toString(),
                            }];
                }
            });
        }); };
        this.statsTokenApy = function () { return __awaiter(_this, void 0, void 0, function () {
            var gaugeContract, lpTokenContract, gaugeControllerContract, totalLiquidityUSD, _a, inflation, weight, workingSupply, totalSupply, rate, crvRate, baseApy, boostedApy;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        if (this.gauge === ethers_1.ethers.constants.AddressZero)
                            throw Error("".concat(this.name, " doesn't have gauge"));
                        if (curve_1.curve.chainId === 137)
                            throw Error("No such method on network with id ".concat(curve_1.curve.chainId, ". Use getRewardsApy instead"));
                        gaugeContract = curve_1.curve.contracts[this.gauge].multicallContract;
                        lpTokenContract = curve_1.curve.contracts[this.lpToken].multicallContract;
                        gaugeControllerContract = curve_1.curve.contracts[curve_1.curve.constants.ALIASES.gauge_controller].multicallContract;
                        return [4 /*yield*/, this.statsTotalLiquidity()];
                    case 1:
                        totalLiquidityUSD = _c.sent();
                        if (Number(totalLiquidityUSD) === 0)
                            return [2 /*return*/, ["0", "0"]];
                        return [4 /*yield*/, curve_1.curve.multicallProvider.all([
                                gaugeContract.inflation_rate(),
                                gaugeControllerContract.gauge_relative_weight(this.gauge),
                                gaugeContract.working_supply(),
                                lpTokenContract.totalSupply(),
                            ])];
                    case 2:
                        _a = (_c.sent()).map(function (value) { return (0, utils_1.toBN)(value); }), inflation = _a[0], weight = _a[1], workingSupply = _a[2], totalSupply = _a[3];
                        if (Number(workingSupply) === 0)
                            return [2 /*return*/, ["0", "0"]];
                        rate = inflation.times(weight).times(31536000).times(0.4).div(workingSupply).times(totalSupply).div(Number(totalLiquidityUSD));
                        return [4 /*yield*/, (0, utils_1._getUsdRate)(curve_1.curve.constants.ALIASES.crv)];
                    case 3:
                        crvRate = _c.sent();
                        baseApy = rate.times(crvRate);
                        boostedApy = baseApy.times(2.5);
                        return [2 /*return*/, [baseApy.times(100).toFixed(4), boostedApy.times(100).toFixed(4)]];
                }
            });
        }); };
        this.statsRewardsApy = function () { return __awaiter(_this, void 0, void 0, function () {
            var apy, _i, _a, rewardToken, rewardContract, totalLiquidityUSD, crvRate, inflation, _c, baseApy, rewardTokenContract, symbol, network, promises, _d, mainPoolsRewards, allTypesExtendedPoolData, rewards, _e, _f, extendedPoolData, _g, _h, pool;
            var _j;
            return __generator(this, function (_k) {
                switch (_k.label) {
                    case 0:
                        if (!(curve_1.curve.chainId === 137)) return [3 /*break*/, 8];
                        apy = [];
                        _i = 0, _a = this.rewardTokens;
                        _k.label = 1;
                    case 1:
                        if (!(_i < _a.length)) return [3 /*break*/, 7];
                        rewardToken = _a[_i];
                        rewardContract = curve_1.curve.contracts[this.rewardContract].contract;
                        return [4 /*yield*/, this.statsTotalLiquidity()];
                    case 2:
                        totalLiquidityUSD = _k.sent();
                        return [4 /*yield*/, (0, utils_1._getUsdRate)(rewardToken)];
                    case 3:
                        crvRate = _k.sent();
                        _c = utils_1.toBN;
                        return [4 /*yield*/, rewardContract.reward_data(curve_1.curve.constants.ALIASES.crv, curve_1.curve.constantOptions)];
                    case 4:
                        inflation = _c.apply(void 0, [(_k.sent()).rate]);
                        baseApy = inflation.times(31536000).times(crvRate).div(Number(totalLiquidityUSD));
                        rewardTokenContract = curve_1.curve.contracts[rewardToken].contract;
                        return [4 /*yield*/, rewardTokenContract.symbol()];
                    case 5:
                        symbol = _k.sent();
                        apy.push({
                            gaugeAddress: this.gauge.toLowerCase(),
                            tokenAddress: rewardToken,
                            symbol: symbol,
                            apy: Number(baseApy.times(100).toFixed(4)),
                        });
                        _k.label = 6;
                    case 6:
                        _i++;
                        return [3 /*break*/, 1];
                    case 7: return [2 /*return*/, apy];
                    case 8:
                        network = curve_1.curve.chainId === 137 ? "polygon" : "ethereum";
                        promises = [
                            (0, external_api_1._getMainPoolsGaugeRewards)(),
                            (0, external_api_1._getPoolsFromApi)(network, "main"),
                            (0, external_api_1._getPoolsFromApi)(network, "crypto"),
                            (0, external_api_1._getPoolsFromApi)(network, "factory"),
                            (0, external_api_1._getPoolsFromApi)(network, "factory-crypto"),
                        ];
                        return [4 /*yield*/, Promise.all(promises)];
                    case 9:
                        _d = _k.sent(), mainPoolsRewards = _d[0], allTypesExtendedPoolData = _d.slice(1);
                        rewards = mainPoolsRewards;
                        for (_e = 0, _f = allTypesExtendedPoolData; _e < _f.length; _e++) {
                            extendedPoolData = _f[_e];
                            for (_g = 0, _h = extendedPoolData.poolData; _g < _h.length; _g++) {
                                pool = _h[_g];
                                if (pool.gaugeAddress && pool.gaugeRewards) {
                                    rewards[pool.gaugeAddress.toLowerCase()] = pool.gaugeRewards;
                                }
                            }
                        }
                        return [2 /*return*/, (_j = rewards[this.gauge.toLowerCase()]) !== null && _j !== void 0 ? _j : []];
                }
            });
        }); };
        // ---------------- ... ----------------
        this.gaugeMaxBoostedDeposit = function () {
            var addresses = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                addresses[_i] = arguments[_i];
            }
            return __awaiter(_this, void 0, void 0, function () {
                var votingEscrowContract, gaugeContract, contractCalls, _response, responseBN, _a, veTotalSupplyBN, gaugeTotalSupplyBN, resultBN, result, _c, _d, entry;
                return __generator(this, function (_e) {
                    switch (_e.label) {
                        case 0:
                            if (this.gauge === ethers_1.ethers.constants.AddressZero)
                                throw Error("".concat(this.name, " doesn't have gauge"));
                            if (addresses.length == 1 && Array.isArray(addresses[0]))
                                addresses = addresses[0];
                            votingEscrowContract = curve_1.curve.contracts[curve_1.curve.constants.ALIASES.voting_escrow].multicallContract;
                            gaugeContract = curve_1.curve.contracts[this.gauge].multicallContract;
                            contractCalls = [votingEscrowContract.totalSupply(), gaugeContract.totalSupply()];
                            addresses.forEach(function (account) {
                                contractCalls.push(votingEscrowContract.balanceOf(account));
                            });
                            return [4 /*yield*/, curve_1.curve.multicallProvider.all(contractCalls)];
                        case 1:
                            _response = _e.sent();
                            responseBN = _response.map(function (value) { return (0, utils_1.toBN)(value); });
                            _a = responseBN.splice(0, 2), veTotalSupplyBN = _a[0], gaugeTotalSupplyBN = _a[1];
                            resultBN = {};
                            addresses.forEach(function (acct, i) {
                                resultBN[acct] = responseBN[i].div(veTotalSupplyBN).times(gaugeTotalSupplyBN);
                            });
                            result = {};
                            for (_c = 0, _d = Object.entries(resultBN); _c < _d.length; _c++) {
                                entry = _d[_c];
                                result[entry[0]] = (0, utils_1.toStringFromBN)(entry[1]);
                            }
                            return [2 /*return*/, result];
                    }
                });
            });
        };
        this.gaugeOptimalDeposits = function () {
            var accounts = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                accounts[_i] = arguments[_i];
            }
            return __awaiter(_this, void 0, void 0, function () {
                var votingEscrowContract, lpTokenContract, gaugeContract, contractCalls, _response, response, _a, veTotalSupply, gaugeTotalSupply, votingPower, totalBalance, _c, accounts_1, acct, totalPower, optimalBN, _d, accounts_2, acct, amount, _e, accounts_3, acct, optimal, _f, _g, entry;
                return __generator(this, function (_h) {
                    switch (_h.label) {
                        case 0:
                            if (this.gauge === ethers_1.ethers.constants.AddressZero)
                                throw Error("".concat(this.name, " doesn't have gauge"));
                            if (accounts.length == 1 && Array.isArray(accounts[0]))
                                accounts = accounts[0];
                            votingEscrowContract = curve_1.curve.contracts[curve_1.curve.constants.ALIASES.voting_escrow].multicallContract;
                            lpTokenContract = curve_1.curve.contracts[this.lpToken].multicallContract;
                            gaugeContract = curve_1.curve.contracts[this.gauge].multicallContract;
                            contractCalls = [votingEscrowContract.totalSupply(), gaugeContract.totalSupply()];
                            accounts.forEach(function (account) {
                                contractCalls.push(votingEscrowContract.balanceOf(account), lpTokenContract.balanceOf(account), gaugeContract.balanceOf(account));
                            });
                            return [4 /*yield*/, curve_1.curve.multicallProvider.all(contractCalls)];
                        case 1:
                            _response = _h.sent();
                            response = _response.map(function (value) { return (0, utils_1.toBN)(value); });
                            _a = response.splice(0, 2), veTotalSupply = _a[0], gaugeTotalSupply = _a[1];
                            votingPower = {};
                            totalBalance = (0, utils_1.BN)(0);
                            for (_c = 0, accounts_1 = accounts; _c < accounts_1.length; _c++) {
                                acct = accounts_1[_c];
                                votingPower[acct] = response[0];
                                totalBalance = totalBalance.plus(response[1]).plus(response[2]);
                                response.splice(0, 3);
                            }
                            totalPower = Object.values(votingPower).reduce(function (sum, item) { return sum.plus(item); });
                            optimalBN = Object.fromEntries(accounts.map(function (acc) { return [acc, (0, utils_1.BN)(0)]; }));
                            if (totalBalance.lt(gaugeTotalSupply.times(totalPower).div(veTotalSupply))) {
                                for (_d = 0, accounts_2 = accounts; _d < accounts_2.length; _d++) {
                                    acct = accounts_2[_d];
                                    amount = gaugeTotalSupply.times(votingPower[acct]).div(veTotalSupply).lt(totalBalance) ?
                                        gaugeTotalSupply.times(votingPower[acct]).div(veTotalSupply) : totalBalance;
                                    optimalBN[acct] = amount;
                                    totalBalance = totalBalance.minus(amount);
                                    if (totalBalance.lte(0)) {
                                        break;
                                    }
                                }
                            }
                            else {
                                if (totalPower.lt(0)) {
                                    for (_e = 0, accounts_3 = accounts; _e < accounts_3.length; _e++) {
                                        acct = accounts_3[_e];
                                        optimalBN[acct] = totalBalance.times(votingPower[acct]).div(totalPower);
                                    }
                                }
                                optimalBN[accounts[0]] = optimalBN[accounts[0]].plus(totalBalance.minus(Object.values(optimalBN).reduce(function (sum, item) { return sum.plus(item); })));
                            }
                            optimal = {};
                            for (_f = 0, _g = Object.entries(optimalBN); _f < _g.length; _f++) {
                                entry = _g[_f];
                                optimal[entry[0]] = (0, utils_1.toStringFromBN)(entry[1]);
                            }
                            return [2 /*return*/, optimal];
                    }
                });
            });
        };
        this.boost = function (address) { return __awaiter(_this, void 0, void 0, function () {
            var gaugeContract, _a, workingBalance, balance, boost;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        if (this.gauge === ethers_1.ethers.constants.AddressZero)
                            throw Error("".concat(this.name, " doesn't have gauge"));
                        gaugeContract = curve_1.curve.contracts[this.gauge].multicallContract;
                        return [4 /*yield*/, curve_1.curve.multicallProvider.all([
                                gaugeContract.working_balances(address),
                                gaugeContract.balanceOf(address),
                            ])];
                    case 1:
                        _a = (_c.sent()).map(function (value) { return Number(ethers_1.ethers.utils.formatUnits(value)); }), workingBalance = _a[0], balance = _a[1];
                        boost = workingBalance / (0.4 * balance);
                        return [2 /*return*/, boost.toFixed(4).replace(/([0-9])0+$/, '$1')];
                }
            });
        }); };
        this._getCoinIdx = function (coin, useUnderlying) {
            if (useUnderlying === void 0) { useUnderlying = true; }
            if (typeof coin === 'number') {
                var coins_N = useUnderlying ? _this.underlyingCoins.length : _this.wrappedCoins.length;
                var idx_1 = coin;
                if (!Number.isInteger(idx_1)) {
                    throw Error('Index must be integer');
                }
                if (idx_1 < 0) {
                    throw Error('Index must be >= 0');
                }
                if (idx_1 > coins_N - 1) {
                    throw Error("Index must be < ".concat(coins_N));
                }
                return idx_1;
            }
            var coinAddress = (0, utils_1._getCoinAddresses)(coin)[0];
            var lowerCaseCoinAddresses = useUnderlying ?
                _this.underlyingCoinAddresses.map(function (c) { return c.toLowerCase(); }) :
                _this.wrappedCoinAddresses.map(function (c) { return c.toLowerCase(); });
            var idx = lowerCaseCoinAddresses.indexOf(coinAddress.toLowerCase());
            if (idx === -1) {
                throw Error("There is no ".concat(coin, " in ").concat(_this.name, " pool")); // TODO add wrapped or underlying
            }
            return idx;
        };
        this._getRates = function () { return __awaiter(_this, void 0, void 0, function () {
            var _rates, i, addr, _a, _c, _d, _e;
            return __generator(this, function (_f) {
                switch (_f.label) {
                    case 0:
                        _rates = [];
                        i = 0;
                        _f.label = 1;
                    case 1:
                        if (!(i < this.wrappedCoinAddresses.length)) return [3 /*break*/, 9];
                        addr = this.wrappedCoinAddresses[i];
                        if (!this.useLending[i]) return [3 /*break*/, 7];
                        if (!['compound', 'usdt', 'ib'].includes(this.id)) return [3 /*break*/, 3];
                        _c = (_a = _rates).push;
                        return [4 /*yield*/, curve_1.curve.contracts[addr].contract.exchangeRateStored()];
                    case 2:
                        _c.apply(_a, [_f.sent()]);
                        return [3 /*break*/, 6];
                    case 3:
                        if (!['y', 'busd', 'pax'].includes(this.id)) return [3 /*break*/, 5];
                        _e = (_d = _rates).push;
                        return [4 /*yield*/, curve_1.curve.contracts[addr].contract.getPricePerFullShare()];
                    case 4:
                        _e.apply(_d, [_f.sent()]);
                        return [3 /*break*/, 6];
                    case 5:
                        _rates.push(ethers_1.ethers.BigNumber.from(10).pow(18)); // Aave ratio 1:1
                        _f.label = 6;
                    case 6: return [3 /*break*/, 8];
                    case 7:
                        _rates.push(ethers_1.ethers.BigNumber.from(10).pow(18));
                        _f.label = 8;
                    case 8:
                        i++;
                        return [3 /*break*/, 1];
                    case 9: return [2 /*return*/, _rates];
                }
            });
        }); };
        this._balances = function (rawCoinNames, rawCoinAddresses) {
            var addresses = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                addresses[_i - 2] = arguments[_i];
            }
            return __awaiter(_this, void 0, void 0, function () {
                var coinNames, coinAddresses, i, rawBalances, balances, _a, addresses_1, address, _c, coinNames_1, coinName;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0:
                            coinNames = [];
                            coinAddresses = [];
                            // removing duplicates
                            for (i = 0; i < rawCoinAddresses.length; i++) {
                                if (!coinAddresses.includes(rawCoinAddresses[i])) {
                                    coinNames.push(rawCoinNames[i]);
                                    coinAddresses.push(rawCoinAddresses[i]);
                                }
                            }
                            addresses = (0, utils_1._prepareAddresses)(addresses);
                            return [4 /*yield*/, (0, utils_1._getBalances)(coinAddresses, addresses)];
                        case 1:
                            rawBalances = _d.sent();
                            balances = {};
                            for (_a = 0, addresses_1 = addresses; _a < addresses_1.length; _a++) {
                                address = addresses_1[_a];
                                balances[address] = {};
                                for (_c = 0, coinNames_1 = coinNames; _c < coinNames_1.length; _c++) {
                                    coinName = coinNames_1[_c];
                                    balances[address][coinName] = rawBalances[address].shift();
                                }
                            }
                            return [2 /*return*/, addresses.length === 1 ? balances[addresses[0]] : balances];
                    }
                });
            });
        };
        this._underlyingPrices = function () { return __awaiter(_this, void 0, void 0, function () {
            var promises, _i, _a, addr;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        promises = [];
                        for (_i = 0, _a = this.underlyingCoinAddresses; _i < _a.length; _i++) {
                            addr = _a[_i];
                            promises.push((0, utils_1._getUsdRate)(addr));
                        }
                        return [4 /*yield*/, Promise.all(promises)];
                    case 1: return [2 /*return*/, _c.sent()];
                }
            });
        }); };
        // NOTE! It may crash!
        this._wrappedPrices = function () { return __awaiter(_this, void 0, void 0, function () {
            var promises, _i, _a, addr;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        promises = [];
                        for (_i = 0, _a = this.wrappedCoinAddresses; _i < _a.length; _i++) {
                            addr = _a[_i];
                            promises.push((0, utils_1._getUsdRate)(addr));
                        }
                        return [4 /*yield*/, Promise.all(promises)];
                    case 1: return [2 /*return*/, _c.sent()];
                }
            });
        }); };
        this._withdrawCryptoBonus = function (totalAmountUSD, lpTokenAmount, useUnderlying) {
            if (useUnderlying === void 0) { useUnderlying = true; }
            return __awaiter(_this, void 0, void 0, function () {
                var prices, _a, balancedAmounts, _c, balancedTotalAmountsUSD;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0:
                            if (!useUnderlying) return [3 /*break*/, 2];
                            return [4 /*yield*/, this._underlyingPrices()];
                        case 1:
                            _a = _d.sent();
                            return [3 /*break*/, 4];
                        case 2: return [4 /*yield*/, this._wrappedPrices()];
                        case 3:
                            _a = _d.sent();
                            _d.label = 4;
                        case 4:
                            prices = _a;
                            if (!useUnderlying) return [3 /*break*/, 6];
                            return [4 /*yield*/, this.withdrawExpected(String(lpTokenAmount))];
                        case 5:
                            _c = _d.sent();
                            return [3 /*break*/, 8];
                        case 6: return [4 /*yield*/, this.withdrawWrappedExpected(String(lpTokenAmount))];
                        case 7:
                            _c = _d.sent();
                            _d.label = 8;
                        case 8:
                            balancedAmounts = _c;
                            balancedTotalAmountsUSD = balancedAmounts.reduce(function (s, b, i) { return s + (Number(b) * prices[i]); }, 0);
                            return [2 /*return*/, String((totalAmountUSD - balancedTotalAmountsUSD) / totalAmountUSD * 100)];
                    }
                });
            });
        };
        // TODO make the same as _withdrawCryptoBonus
        this._withdrawBonus = function (totalAmount, expected, useUnderlying) {
            if (useUnderlying === void 0) { useUnderlying = true; }
            return __awaiter(_this, void 0, void 0, function () {
                var poolBalances, _a, poolTotalBalance, poolBalancesRatios, balancedAmounts, balancedExpected, _c, _d, _e;
                return __generator(this, function (_f) {
                    switch (_f.label) {
                        case 0:
                            if (!useUnderlying) return [3 /*break*/, 2];
                            return [4 /*yield*/, this.stats.underlyingBalances()];
                        case 1:
                            _a = (_f.sent()).map(Number);
                            return [3 /*break*/, 4];
                        case 2: return [4 /*yield*/, this.stats.wrappedBalances()];
                        case 3:
                            _a = (_f.sent()).map(Number);
                            _f.label = 4;
                        case 4:
                            poolBalances = _a;
                            poolTotalBalance = poolBalances.reduce(function (a, b) { return a + b; });
                            poolBalancesRatios = poolBalances.map(function (b) { return b / poolTotalBalance; });
                            balancedAmounts = poolBalancesRatios.map(function (r) { return String(r * totalAmount); });
                            if (!useUnderlying) return [3 /*break*/, 6];
                            _d = Number;
                            return [4 /*yield*/, this.withdrawImbalanceExpected(balancedAmounts)];
                        case 5:
                            _c = _d.apply(void 0, [_f.sent()]);
                            return [3 /*break*/, 8];
                        case 6:
                            _e = Number;
                            return [4 /*yield*/, this.withdrawImbalanceWrappedExpected(balancedAmounts)];
                        case 7:
                            _c = _e.apply(void 0, [_f.sent()]);
                            _f.label = 8;
                        case 8:
                            balancedExpected = _c;
                            return [2 /*return*/, String((balancedExpected - expected) / balancedExpected * 100)];
                    }
                });
            });
        };
        var poolData = __assign(__assign(__assign({}, curve_1.curve.constants.POOLS_DATA), curve_1.curve.constants.FACTORY_POOLS_DATA), curve_1.curve.constants.CRYPTO_FACTORY_POOLS_DATA)[id];
        this.id = id;
        this.name = poolData.name;
        this.fullName = poolData.full_name;
        this.symbol = poolData.symbol;
        this.referenceAsset = poolData.reference_asset;
        this.address = poolData.swap_address;
        this.lpToken = poolData.token_address;
        this.gauge = poolData.gauge_address;
        this.zap = poolData.deposit_address || null;
        this.rewardContract = poolData.reward_contract || null;
        this.isPlain = poolData.is_plain || false;
        this.isLending = poolData.is_lending || false;
        this.isMeta = poolData.is_meta || false;
        this.isCrypto = poolData.is_crypto || false;
        this.isFake = poolData.is_fake || false;
        this.isFactory = poolData.is_factory || false;
        this.isMetaFactory = (this.isMeta && this.isFactory) || this.zap === '0xa79828df1850e8a3a3064576f380d90aecdd3359';
        this.basePool = poolData.base_pool || '';
        this.underlyingCoins = poolData.underlying_coins;
        this.wrappedCoins = poolData.wrapped_coins;
        this.underlyingCoinAddresses = poolData.underlying_coin_addresses;
        this.wrappedCoinAddresses = poolData.wrapped_coin_addresses;
        this.underlyingDecimals = poolData.underlying_decimals;
        this.wrappedDecimals = poolData.wrapped_decimals;
        this.useLending = poolData.use_lending || poolData.underlying_coin_addresses.map(function () { return false; });
        this.rewardTokens = poolData.reward_tokens || [];
        this.estimateGas = {
            depositApprove: this.depositApproveEstimateGas.bind(this),
            deposit: this.depositEstimateGas.bind(this),
            depositWrappedApprove: this.depositWrappedApproveEstimateGas.bind(this),
            depositWrapped: this.depositWrappedEstimateGas.bind(this),
            stakeApprove: this.stakeApproveEstimateGas.bind(this),
            stake: this.stakeEstimateGas.bind(this),
            unstake: this.unstakeEstimateGas.bind(this),
            claimCrv: this.claimCrvEstimateGas.bind(this),
            claimRewards: this.claimRewardsEstimateGas.bind(this),
            depositAndStakeApprove: this.depositAndStakeApproveEstimateGas.bind(this),
            depositAndStake: this.depositAndStakeEstimateGas.bind(this),
            depositAndStakeWrappedApprove: this.depositAndStakeWrappedApproveEstimateGas.bind(this),
            depositAndStakeWrapped: this.depositAndStakeWrappedEstimateGas.bind(this),
            withdrawApprove: this.withdrawApproveEstimateGas.bind(this),
            withdraw: this.withdrawEstimateGas.bind(this),
            withdrawWrapped: this.withdrawWrappedEstimateGas.bind(this),
            withdrawImbalanceApprove: this.withdrawImbalanceApproveEstimateGas.bind(this),
            withdrawImbalance: this.withdrawImbalanceEstimateGas.bind(this),
            withdrawImbalanceWrapped: this.withdrawImbalanceWrappedEstimateGas.bind(this),
            withdrawOneCoinApprove: this.withdrawOneCoinApproveEstimateGas.bind(this),
            withdrawOneCoin: this.withdrawOneCoinEstimateGas.bind(this),
            withdrawOneCoinWrapped: this.withdrawOneCoinWrappedEstimateGas.bind(this),
            swapApprove: this.swapApproveEstimateGas.bind(this),
            swap: this.swapEstimateGas.bind(this),
            swapWrappedApprove: this.swapWrappedApproveEstimateGas.bind(this),
            swapWrapped: this.swapWrappedEstimateGas.bind(this),
        };
        this.stats = {
            parameters: this.statsParameters.bind(this),
            underlyingBalances: this.statsUnderlyingBalances.bind(this),
            wrappedBalances: this.statsWrappedBalances.bind(this),
            totalLiquidity: this.statsTotalLiquidity.bind(this),
            volume: this.statsVolume.bind(this),
            baseApy: this.statsBaseApy.bind(this),
            tokenApy: this.statsTokenApy.bind(this),
            rewardsApy: this.statsRewardsApy.bind(this),
        };
        this.wallet = {
            balances: this.walletBalances.bind(this),
            lpTokenBalances: this.walletLpTokenBalances.bind(this),
            underlyingCoinBalances: this.walletUnderlyingCoinBalances.bind(this),
            wrappedCoinBalances: this.walletWrappedCoinBalances.bind(this),
            allCoinBalances: this.walletAllCoinBalances.bind(this),
        };
    }
    PoolTemplate.prototype.statsWrappedBalances = function () {
        return __awaiter(this, void 0, void 0, function () {
            var swapContract, contractCalls, _wrappedBalances;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        swapContract = curve_1.curve.contracts[this.address].multicallContract;
                        contractCalls = this.wrappedCoins.map(function (_, i) { return swapContract.balances(i); });
                        return [4 /*yield*/, curve_1.curve.multicallProvider.all(contractCalls)];
                    case 1:
                        _wrappedBalances = _a.sent();
                        return [2 /*return*/, _wrappedBalances.map(function (_b, i) { return ethers_1.ethers.utils.formatUnits(_b, _this.wrappedDecimals[i]); })];
                }
            });
        });
    };
    // OVERRIDE
    PoolTemplate.prototype.statsUnderlyingBalances = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.statsWrappedBalances()];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    PoolTemplate.prototype._calcLpTokenAmount = function (_amounts, isDeposit, useUnderlying) {
        if (isDeposit === void 0) { isDeposit = true; }
        if (useUnderlying === void 0) { useUnderlying = true; }
        return __awaiter(this, void 0, void 0, function () {
            var _rates_1, contractAddress, contract;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(!this.isMeta && useUnderlying)) return [3 /*break*/, 2];
                        return [4 /*yield*/, this._getRates()];
                    case 1:
                        _rates_1 = _a.sent();
                        _amounts = _amounts.map(function (_amount, i) {
                            return _amount.mul(ethers_1.ethers.BigNumber.from(10).pow(18)).div(_rates_1[i]);
                        });
                        _a.label = 2;
                    case 2:
                        contractAddress = this.isMeta && useUnderlying ? this.zap : this.address;
                        contract = curve_1.curve.contracts[contractAddress].contract;
                        if (!(this.isMetaFactory && useUnderlying)) return [3 /*break*/, 4];
                        return [4 /*yield*/, contract.calc_token_amount(this.address, _amounts, isDeposit, curve_1.curve.constantOptions)];
                    case 3: return [2 /*return*/, _a.sent()];
                    case 4:
                        if (!contract["calc_token_amount(uint256[".concat(_amounts.length, "],bool)")]) return [3 /*break*/, 6];
                        return [4 /*yield*/, contract.calc_token_amount(_amounts, isDeposit, curve_1.curve.constantOptions)];
                    case 5: return [2 /*return*/, _a.sent()];
                    case 6: return [4 /*yield*/, contract.calc_token_amount(_amounts, curve_1.curve.constantOptions)];
                    case 7: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    PoolTemplate.prototype.calcLpTokenAmount = function (amounts, isDeposit) {
        if (isDeposit === void 0) { isDeposit = true; }
        return __awaiter(this, void 0, void 0, function () {
            var _underlyingAmounts, _expected;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (amounts.length !== this.underlyingCoinAddresses.length) {
                            throw Error("".concat(this.name, " pool has ").concat(this.underlyingCoinAddresses.length, " coins (amounts provided for ").concat(amounts.length, ")"));
                        }
                        _underlyingAmounts = amounts.map(function (amount, i) { return (0, utils_1.parseUnits)(amount, _this.underlyingDecimals[i]); });
                        return [4 /*yield*/, this._calcLpTokenAmount(_underlyingAmounts, isDeposit, true)];
                    case 1:
                        _expected = _a.sent();
                        return [2 /*return*/, ethers_1.ethers.utils.formatUnits(_expected)];
                }
            });
        });
    };
    PoolTemplate.prototype.calcLpTokenAmountWrapped = function (amounts, isDeposit) {
        if (isDeposit === void 0) { isDeposit = true; }
        return __awaiter(this, void 0, void 0, function () {
            var _amounts, _expected;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (amounts.length !== this.wrappedCoinAddresses.length) {
                            throw Error("".concat(this.name, " pool has ").concat(this.wrappedCoinAddresses.length, " coins (amounts provided for ").concat(amounts.length, ")"));
                        }
                        if (this.isFake) {
                            throw Error("".concat(this.name, " pool doesn't have this method"));
                        }
                        _amounts = amounts.map(function (amount, i) { return (0, utils_1.parseUnits)(amount, _this.wrappedDecimals[i]); });
                        return [4 /*yield*/, this._calcLpTokenAmount(_amounts, isDeposit, false)];
                    case 1:
                        _expected = _a.sent();
                        return [2 /*return*/, ethers_1.ethers.utils.formatUnits(_expected)];
                }
            });
        });
    };
    // ---------------- DEPOSIT ----------------
    PoolTemplate.prototype.depositBalancedAmounts = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                throw Error("depositBalancedAmounts method doesn't exist for pool ".concat(this.name, " (id: ").concat(this.name, ")"));
            });
        });
    };
    PoolTemplate.prototype.depositExpected = function (amounts) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.calcLpTokenAmount(amounts)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    // OVERRIDE
    PoolTemplate.prototype.depositBonus = function (amounts) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                throw Error("depositBonus method doesn't exist for pool ".concat(this.name, " (id: ").concat(this.name, ")"));
            });
        });
    };
    PoolTemplate.prototype.depositIsApproved = function (amounts) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, utils_1.hasAllowance)(this.underlyingCoinAddresses, amounts, curve_1.curve.signerAddress, this.zap || this.address)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    PoolTemplate.prototype.depositApproveEstimateGas = function (amounts) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, utils_1.ensureAllowanceEstimateGas)(this.underlyingCoinAddresses, amounts, this.zap || this.address)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    PoolTemplate.prototype.depositApprove = function (amounts) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, utils_1.ensureAllowance)(this.underlyingCoinAddresses, amounts, this.zap || this.address)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    // OVERRIDE
    PoolTemplate.prototype.depositEstimateGas = function (amounts) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                throw Error("depositEstimateGas method doesn't exist for pool ".concat(this.name, " (id: ").concat(this.name, ")"));
            });
        });
    };
    // OVERRIDE
    PoolTemplate.prototype.deposit = function (amounts, slippage) {
        if (slippage === void 0) { slippage = 0.5; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                throw Error("deposit method doesn't exist for pool ".concat(this.name, " (id: ").concat(this.name, ")"));
            });
        });
    };
    // ---------------- DEPOSIT WRAPPED ----------------
    PoolTemplate.prototype.depositWrappedBalancedAmounts = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                throw Error("depositWrappedBalancedAmounts method doesn't exist for pool ".concat(this.name, " (id: ").concat(this.name, ")"));
            });
        });
    };
    PoolTemplate.prototype.depositWrappedExpected = function (amounts) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.isFake) {
                            throw Error("depositWrappedExpected method doesn't exist for pool ".concat(this.name, " (id: ").concat(this.name, ")"));
                        }
                        return [4 /*yield*/, this.calcLpTokenAmountWrapped(amounts)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    // OVERRIDE
    PoolTemplate.prototype.depositWrappedBonus = function (amounts) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                throw Error("depositWrappedBonus method doesn't exist for pool ".concat(this.name, " (id: ").concat(this.name, ")"));
            });
        });
    };
    PoolTemplate.prototype.depositWrappedIsApproved = function (amounts) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.isFake) {
                            throw Error("depositWrappedIsApproved method doesn't exist for pool ".concat(this.name, " (id: ").concat(this.name, ")"));
                        }
                        return [4 /*yield*/, (0, utils_1.hasAllowance)(this.wrappedCoinAddresses, amounts, curve_1.curve.signerAddress, this.address)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    PoolTemplate.prototype.depositWrappedApproveEstimateGas = function (amounts) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.isFake) {
                            throw Error("depositWrappedApprove method doesn't exist for pool ".concat(this.name, " (id: ").concat(this.name, ")"));
                        }
                        return [4 /*yield*/, (0, utils_1.ensureAllowanceEstimateGas)(this.wrappedCoinAddresses, amounts, this.address)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    PoolTemplate.prototype.depositWrappedApprove = function (amounts) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.isFake) {
                            throw Error("depositWrappedApprove method doesn't exist for pool ".concat(this.name, " (id: ").concat(this.name, ")"));
                        }
                        return [4 /*yield*/, (0, utils_1.ensureAllowance)(this.wrappedCoinAddresses, amounts, this.address)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    // OVERRIDE
    PoolTemplate.prototype.depositWrappedEstimateGas = function (amounts) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                throw Error("depositWrapped method doesn't exist for pool ".concat(this.name, " (id: ").concat(this.name, ")"));
            });
        });
    };
    // OVERRIDE
    PoolTemplate.prototype.depositWrapped = function (amounts, slippage) {
        if (slippage === void 0) { slippage = 0.5; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                throw Error("depositWrapped method doesn't exist for pool ".concat(this.name, " (id: ").concat(this.name, ")"));
            });
        });
    };
    // ---------------- STAKING ----------------
    PoolTemplate.prototype.stakeIsApproved = function (lpTokenAmount) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.gauge === ethers_1.ethers.constants.AddressZero) {
                            throw Error("stakeIsApproved method doesn't exist for pool ".concat(this.name, " (id: ").concat(this.name, "). There is no gauge"));
                        }
                        return [4 /*yield*/, (0, utils_1.hasAllowance)([this.lpToken], [lpTokenAmount], curve_1.curve.signerAddress, this.gauge)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    PoolTemplate.prototype.stakeApproveEstimateGas = function (lpTokenAmount) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.gauge === ethers_1.ethers.constants.AddressZero) {
                            throw Error("stakeApproveEstimateGas method doesn't exist for pool ".concat(this.name, " (id: ").concat(this.name, "). There is no gauge"));
                        }
                        return [4 /*yield*/, (0, utils_1.ensureAllowanceEstimateGas)([this.lpToken], [lpTokenAmount], this.gauge)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    PoolTemplate.prototype.stakeApprove = function (lpTokenAmount) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.gauge === ethers_1.ethers.constants.AddressZero) {
                            throw Error("stakeApprove method doesn't exist for pool ".concat(this.name, " (id: ").concat(this.name, "). There is no gauge"));
                        }
                        return [4 /*yield*/, (0, utils_1.ensureAllowance)([this.lpToken], [lpTokenAmount], this.gauge)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    PoolTemplate.prototype.stakeEstimateGas = function (lpTokenAmount) {
        return __awaiter(this, void 0, void 0, function () {
            var _lpTokenAmount;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.gauge === ethers_1.ethers.constants.AddressZero) {
                            throw Error("stakeEstimateGas method doesn't exist for pool ".concat(this.name, " (id: ").concat(this.name, "). There is no gauge"));
                        }
                        _lpTokenAmount = (0, utils_1.parseUnits)(lpTokenAmount);
                        return [4 /*yield*/, curve_1.curve.contracts[this.gauge].contract.estimateGas.deposit(_lpTokenAmount, curve_1.curve.constantOptions)];
                    case 1: return [2 /*return*/, (_a.sent()).toNumber()];
                }
            });
        });
    };
    PoolTemplate.prototype.stake = function (lpTokenAmount) {
        return __awaiter(this, void 0, void 0, function () {
            var _lpTokenAmount, gasLimit;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.gauge === ethers_1.ethers.constants.AddressZero) {
                            throw Error("stake method doesn't exist for pool ".concat(this.name, " (id: ").concat(this.name, "). There is no gauge"));
                        }
                        _lpTokenAmount = (0, utils_1.parseUnits)(lpTokenAmount);
                        return [4 /*yield*/, (0, utils_1._ensureAllowance)([this.lpToken], [_lpTokenAmount], this.gauge)];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, curve_1.curve.contracts[this.gauge].contract.estimateGas.deposit(_lpTokenAmount, curve_1.curve.constantOptions)];
                    case 2:
                        gasLimit = (_a.sent()).mul(150).div(100);
                        return [4 /*yield*/, curve_1.curve.contracts[this.gauge].contract.deposit(_lpTokenAmount, __assign(__assign({}, curve_1.curve.options), { gasLimit: gasLimit }))];
                    case 3: return [2 /*return*/, (_a.sent()).hash];
                }
            });
        });
    };
    PoolTemplate.prototype.unstakeEstimateGas = function (lpTokenAmount) {
        return __awaiter(this, void 0, void 0, function () {
            var _lpTokenAmount;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.gauge === ethers_1.ethers.constants.AddressZero) {
                            throw Error("unstakeEstimateGas method doesn't exist for pool ".concat(this.name, " (id: ").concat(this.name, "). There is no gauge"));
                        }
                        _lpTokenAmount = (0, utils_1.parseUnits)(lpTokenAmount);
                        return [4 /*yield*/, curve_1.curve.contracts[this.gauge].contract.estimateGas.withdraw(_lpTokenAmount, curve_1.curve.constantOptions)];
                    case 1: return [2 /*return*/, (_a.sent()).toNumber()];
                }
            });
        });
    };
    PoolTemplate.prototype.unstake = function (lpTokenAmount) {
        return __awaiter(this, void 0, void 0, function () {
            var _lpTokenAmount, gasLimit;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.gauge === ethers_1.ethers.constants.AddressZero) {
                            throw Error("unstake method doesn't exist for pool ".concat(this.name, " (id: ").concat(this.name, "). There is no gauge"));
                        }
                        _lpTokenAmount = (0, utils_1.parseUnits)(lpTokenAmount);
                        return [4 /*yield*/, curve_1.curve.contracts[this.gauge].contract.estimateGas.withdraw(_lpTokenAmount, curve_1.curve.constantOptions)];
                    case 1:
                        gasLimit = (_a.sent()).mul(200).div(100);
                        return [4 /*yield*/, curve_1.curve.contracts[this.gauge].contract.withdraw(_lpTokenAmount, __assign(__assign({}, curve_1.curve.options), { gasLimit: gasLimit }))];
                    case 2: return [2 /*return*/, (_a.sent()).hash];
                }
            });
        });
    };
    PoolTemplate.prototype.claimableCrv = function (address) {
        if (address === void 0) { address = ""; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, _c;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        if (this.gauge === ethers_1.ethers.constants.AddressZero) {
                            throw Error("claimableCrv method doesn't exist for pool ".concat(this.name, " (id: ").concat(this.name, "). There is no gauge"));
                        }
                        if (curve_1.curve.chainId !== 1)
                            throw Error("No such method on network with id ".concat(curve_1.curve.chainId, ". Use claimableRewards instead"));
                        address = address || curve_1.curve.signerAddress;
                        if (!address)
                            throw Error("Need to connect wallet or pass address into args");
                        _c = (_a = ethers_1.ethers.utils).formatUnits;
                        return [4 /*yield*/, curve_1.curve.contracts[this.gauge].contract.claimable_tokens(address, curve_1.curve.constantOptions)];
                    case 1: return [2 /*return*/, _c.apply(_a, [_d.sent()])];
                }
            });
        });
    };
    PoolTemplate.prototype.claimCrvEstimateGas = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.gauge === ethers_1.ethers.constants.AddressZero) {
                            throw Error("claimCrv method doesn't exist for pool ".concat(this.name, " (id: ").concat(this.name, "). There is no gauge"));
                        }
                        if (curve_1.curve.chainId !== 1)
                            throw Error("No such method on network with id ".concat(curve_1.curve.chainId, ". Use claimRewards instead"));
                        return [4 /*yield*/, curve_1.curve.contracts[curve_1.curve.constants.ALIASES.minter].contract.estimateGas.mint(this.gauge, curve_1.curve.constantOptions)];
                    case 1: return [2 /*return*/, (_a.sent()).toNumber()];
                }
            });
        });
    };
    PoolTemplate.prototype.claimCrv = function () {
        return __awaiter(this, void 0, void 0, function () {
            var gasLimit;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.gauge === ethers_1.ethers.constants.AddressZero) {
                            throw Error("claimCrv method doesn't exist for pool ".concat(this.name, " (id: ").concat(this.name, "). There is no gauge"));
                        }
                        if (curve_1.curve.chainId !== 1)
                            throw Error("No such method on network with id ".concat(curve_1.curve.chainId, ". Use claimRewards instead"));
                        return [4 /*yield*/, curve_1.curve.contracts[curve_1.curve.constants.ALIASES.minter].contract.estimateGas.mint(this.gauge, curve_1.curve.constantOptions)];
                    case 1:
                        gasLimit = (_a.sent()).mul(130).div(100);
                        return [4 /*yield*/, curve_1.curve.contracts[curve_1.curve.constants.ALIASES.minter].contract.mint(this.gauge, __assign(__assign({}, curve_1.curve.options), { gasLimit: gasLimit }))];
                    case 2: return [2 /*return*/, (_a.sent()).hash];
                }
            });
        });
    };
    // TODO 1. Fix aave and saave error
    // TODO 2. Figure out Synthetix cumulative results
    PoolTemplate.prototype.claimableRewards = function (address) {
        if (address === void 0) { address = ""; }
        return __awaiter(this, void 0, void 0, function () {
            var gaugeContract, rewards, _i, _a, rewardToken, rewardTokenContract, symbol, decimals, method, amount, _c, _d, rewardToken, rewardTokenContract, symbol, decimals, amount, _e, _f;
            return __generator(this, function (_g) {
                switch (_g.label) {
                    case 0:
                        if (this.gauge === ethers_1.ethers.constants.AddressZero) {
                            throw Error("claimableRewards method doesn't exist for pool ".concat(this.name, " (id: ").concat(this.name, "). There is no gauge"));
                        }
                        address = address || curve_1.curve.signerAddress;
                        if (!address)
                            throw Error("Need to connect wallet or pass address into args");
                        gaugeContract = curve_1.curve.contracts[this.gauge].contract;
                        rewards = [];
                        if (!('claimable_reward(address,address)' in gaugeContract)) return [3 /*break*/, 7];
                        _i = 0, _a = this.rewardTokens;
                        _g.label = 1;
                    case 1:
                        if (!(_i < _a.length)) return [3 /*break*/, 6];
                        rewardToken = _a[_i];
                        rewardTokenContract = curve_1.curve.contracts[rewardToken].contract;
                        return [4 /*yield*/, rewardTokenContract.symbol()];
                    case 2:
                        symbol = _g.sent();
                        return [4 /*yield*/, rewardTokenContract.decimals()];
                    case 3:
                        decimals = _g.sent();
                        method = curve_1.curve.chainId === 1 ? "claimable_reward" : "claimable_reward_write";
                        _d = (_c = ethers_1.ethers.utils).formatUnits;
                        return [4 /*yield*/, gaugeContract[method](address, rewardToken, curve_1.curve.constantOptions)];
                    case 4:
                        amount = _d.apply(_c, [_g.sent(), decimals]);
                        rewards.push({
                            token: rewardToken,
                            symbol: symbol,
                            amount: amount,
                        });
                        _g.label = 5;
                    case 5:
                        _i++;
                        return [3 /*break*/, 1];
                    case 6: return [3 /*break*/, 11];
                    case 7:
                        if (!('claimable_reward(address)' in gaugeContract && this.rewardTokens.length > 0)) return [3 /*break*/, 11];
                        rewardToken = this.rewardTokens[0];
                        rewardTokenContract = curve_1.curve.contracts[rewardToken].contract;
                        return [4 /*yield*/, rewardTokenContract.symbol()];
                    case 8:
                        symbol = _g.sent();
                        return [4 /*yield*/, rewardTokenContract.decimals()];
                    case 9:
                        decimals = _g.sent();
                        _f = (_e = ethers_1.ethers.utils).formatUnits;
                        return [4 /*yield*/, gaugeContract.claimable_reward(address, curve_1.curve.constantOptions)];
                    case 10:
                        amount = _f.apply(_e, [_g.sent(), decimals]);
                        rewards.push({
                            token: rewardToken,
                            symbol: symbol,
                            amount: amount,
                        });
                        _g.label = 11;
                    case 11: return [2 /*return*/, rewards];
                }
            });
        });
    };
    PoolTemplate.prototype.claimRewardsEstimateGas = function () {
        return __awaiter(this, void 0, void 0, function () {
            var gaugeContract;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.gauge === ethers_1.ethers.constants.AddressZero) {
                            throw Error("claimRewards method doesn't exist for pool ".concat(this.name, " (id: ").concat(this.name, "). There is no gauge"));
                        }
                        gaugeContract = curve_1.curve.contracts[this.gauge].contract;
                        if (!("claim_rewards()" in gaugeContract))
                            throw Error("".concat(this.name, " pool doesn't have such method"));
                        return [4 /*yield*/, gaugeContract.estimateGas.claim_rewards(curve_1.curve.constantOptions)];
                    case 1: return [2 /*return*/, (_a.sent()).toNumber()];
                }
            });
        });
    };
    PoolTemplate.prototype.claimRewards = function () {
        return __awaiter(this, void 0, void 0, function () {
            var gaugeContract, gasLimit;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.gauge === ethers_1.ethers.constants.AddressZero) {
                            throw Error("claimRewards method doesn't exist for pool ".concat(this.name, " (id: ").concat(this.name, "). There is no gauge"));
                        }
                        gaugeContract = curve_1.curve.contracts[this.gauge].contract;
                        if (!("claim_rewards()" in gaugeContract))
                            throw Error("".concat(this.name, " pool doesn't have such method"));
                        return [4 /*yield*/, gaugeContract.estimateGas.claim_rewards(curve_1.curve.constantOptions)];
                    case 1:
                        gasLimit = (_a.sent()).mul(130).div(100);
                        return [4 /*yield*/, gaugeContract.claim_rewards(__assign(__assign({}, curve_1.curve.options), { gasLimit: gasLimit }))];
                    case 2: return [2 /*return*/, (_a.sent()).hash];
                }
            });
        });
    };
    // ---------------- DEPOSIT & STAKE ----------------
    PoolTemplate.prototype.depositAndStakeExpected = function (amounts) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.gauge === ethers_1.ethers.constants.AddressZero) {
                            throw Error("depositAndStakeExpected method doesn't exist for pool ".concat(this.name, " (id: ").concat(this.name, "). There is no gauge"));
                        }
                        return [4 /*yield*/, this.depositExpected(amounts)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    PoolTemplate.prototype.depositAndStakeBonus = function (amounts) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.gauge === ethers_1.ethers.constants.AddressZero) {
                            throw Error("depositAndStakeBonus method doesn't exist for pool ".concat(this.name, " (id: ").concat(this.name, "). There is no gauge"));
                        }
                        return [4 /*yield*/, this.depositBonus(amounts)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    PoolTemplate.prototype.depositAndStakeIsApproved = function (amounts) {
        return __awaiter(this, void 0, void 0, function () {
            var coinsAllowance, gaugeContract, gaugeAllowance;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.gauge === ethers_1.ethers.constants.AddressZero) {
                            throw Error("depositAndStakeIsApproved method doesn't exist for pool ".concat(this.name, " (id: ").concat(this.name, "). There is no gauge"));
                        }
                        return [4 /*yield*/, (0, utils_1.hasAllowance)(this.underlyingCoinAddresses, amounts, curve_1.curve.signerAddress, curve_1.curve.constants.ALIASES.deposit_and_stake)];
                    case 1:
                        coinsAllowance = _a.sent();
                        gaugeContract = curve_1.curve.contracts[this.gauge].contract;
                        if (!Object.prototype.hasOwnProperty.call(gaugeContract, 'approved_to_deposit')) return [3 /*break*/, 3];
                        return [4 /*yield*/, gaugeContract.approved_to_deposit(curve_1.curve.constants.ALIASES.deposit_and_stake, curve_1.curve.signerAddress, curve_1.curve.constantOptions)];
                    case 2:
                        gaugeAllowance = _a.sent();
                        return [2 /*return*/, coinsAllowance && gaugeAllowance];
                    case 3: return [2 /*return*/, coinsAllowance];
                }
            });
        });
    };
    PoolTemplate.prototype.depositAndStakeApproveEstimateGas = function (amounts) {
        return __awaiter(this, void 0, void 0, function () {
            var approveCoinsGas, gaugeContract, gaugeAllowance, approveGaugeGas;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.gauge === ethers_1.ethers.constants.AddressZero) {
                            throw Error("depositAndStakeApprove method doesn't exist for pool ".concat(this.name, " (id: ").concat(this.name, "). There is no gauge"));
                        }
                        return [4 /*yield*/, (0, utils_1.ensureAllowanceEstimateGas)(this.underlyingCoinAddresses, amounts, curve_1.curve.constants.ALIASES.deposit_and_stake)];
                    case 1:
                        approveCoinsGas = _a.sent();
                        gaugeContract = curve_1.curve.contracts[this.gauge].contract;
                        if (!Object.prototype.hasOwnProperty.call(gaugeContract, 'approved_to_deposit')) return [3 /*break*/, 4];
                        return [4 /*yield*/, gaugeContract.approved_to_deposit(curve_1.curve.constants.ALIASES.deposit_and_stake, curve_1.curve.signerAddress, curve_1.curve.constantOptions)];
                    case 2:
                        gaugeAllowance = _a.sent();
                        if (!!gaugeAllowance) return [3 /*break*/, 4];
                        return [4 /*yield*/, gaugeContract.estimateGas.set_approve_deposit(curve_1.curve.constants.ALIASES.deposit_and_stake, true, curve_1.curve.constantOptions)];
                    case 3:
                        approveGaugeGas = (_a.sent()).toNumber();
                        return [2 /*return*/, approveCoinsGas + approveGaugeGas];
                    case 4: return [2 /*return*/, approveCoinsGas];
                }
            });
        });
    };
    PoolTemplate.prototype.depositAndStakeApprove = function (amounts) {
        return __awaiter(this, void 0, void 0, function () {
            var approveCoinsTx, gaugeContract, gaugeAllowance, gasLimit, approveGaugeTx;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.gauge === ethers_1.ethers.constants.AddressZero) {
                            throw Error("depositAndStakeApprove method doesn't exist for pool ".concat(this.name, " (id: ").concat(this.name, "). There is no gauge"));
                        }
                        return [4 /*yield*/, (0, utils_1.ensureAllowance)(this.underlyingCoinAddresses, amounts, curve_1.curve.constants.ALIASES.deposit_and_stake)];
                    case 1:
                        approveCoinsTx = _a.sent();
                        gaugeContract = curve_1.curve.contracts[this.gauge].contract;
                        if (!Object.prototype.hasOwnProperty.call(gaugeContract, 'approved_to_deposit')) return [3 /*break*/, 5];
                        return [4 /*yield*/, gaugeContract.approved_to_deposit(curve_1.curve.constants.ALIASES.deposit_and_stake, curve_1.curve.signerAddress, curve_1.curve.constantOptions)];
                    case 2:
                        gaugeAllowance = _a.sent();
                        if (!!gaugeAllowance) return [3 /*break*/, 5];
                        return [4 /*yield*/, gaugeContract.estimateGas.set_approve_deposit(curve_1.curve.constants.ALIASES.deposit_and_stake, true, curve_1.curve.constantOptions)];
                    case 3:
                        gasLimit = (_a.sent()).mul(130).div(100);
                        return [4 /*yield*/, gaugeContract.set_approve_deposit(curve_1.curve.constants.ALIASES.deposit_and_stake, true, __assign(__assign({}, curve_1.curve.options), { gasLimit: gasLimit }))];
                    case 4:
                        approveGaugeTx = (_a.sent()).hash;
                        return [2 /*return*/, __spreadArray(__spreadArray([], approveCoinsTx, true), [approveGaugeTx], false)];
                    case 5: return [2 /*return*/, approveCoinsTx];
                }
            });
        });
    };
    PoolTemplate.prototype.depositAndStakeEstimateGas = function (amounts) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.gauge === ethers_1.ethers.constants.AddressZero) {
                            throw Error("depositAndStake method doesn't exist for pool ".concat(this.name, " (id: ").concat(this.name, "). There is no gauge"));
                        }
                        return [4 /*yield*/, this._depositAndStake(amounts, true, true)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    PoolTemplate.prototype.depositAndStake = function (amounts) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.gauge === ethers_1.ethers.constants.AddressZero) {
                            throw Error("depositAndStake method doesn't exist for pool ".concat(this.name, " (id: ").concat(this.name, "). There is no gauge"));
                        }
                        return [4 /*yield*/, this._depositAndStake(amounts, true, false)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    // ---------------- DEPOSIT & STAKE WRAPPED ----------------
    PoolTemplate.prototype.depositAndStakeWrappedExpected = function (amounts) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.gauge === ethers_1.ethers.constants.AddressZero) {
                            throw Error("depositAndStakeWrappedExpected method doesn't exist for pool ".concat(this.name, " (id: ").concat(this.name, "). There is no gauge"));
                        }
                        if (this.isFake)
                            throw Error("depositAndStakeWrappedExpected method doesn't exist for pool ".concat(this.name, " (id: ").concat(this.name, ")"));
                        return [4 /*yield*/, this.depositWrappedExpected(amounts)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    PoolTemplate.prototype.depositAndStakeWrappedBonus = function (amounts) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.gauge === ethers_1.ethers.constants.AddressZero) {
                            throw Error("depositAndStakeWrappedBonus method doesn't exist for pool ".concat(this.name, " (id: ").concat(this.name, "). There is no gauge"));
                        }
                        if (this.isFake)
                            throw Error("depositAndStakeWrappedBonus method doesn't exist for pool ".concat(this.name, " (id: ").concat(this.name, ")"));
                        return [4 /*yield*/, this.depositWrappedBonus(amounts)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    PoolTemplate.prototype.depositAndStakeWrappedIsApproved = function (amounts) {
        return __awaiter(this, void 0, void 0, function () {
            var coinsAllowance, gaugeContract, gaugeAllowance;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.gauge === ethers_1.ethers.constants.AddressZero) {
                            throw Error("depositAndStakeWrappedIsApproved method doesn't exist for pool ".concat(this.name, " (id: ").concat(this.name, "). There is no gauge"));
                        }
                        if (this.isFake)
                            throw Error("depositAndStakeWrappedIsApproved method doesn't exist for pool ".concat(this.name, " (id: ").concat(this.name, ")"));
                        return [4 /*yield*/, (0, utils_1.hasAllowance)(this.wrappedCoinAddresses, amounts, curve_1.curve.signerAddress, curve_1.curve.constants.ALIASES.deposit_and_stake)];
                    case 1:
                        coinsAllowance = _a.sent();
                        gaugeContract = curve_1.curve.contracts[this.gauge].contract;
                        if (!Object.prototype.hasOwnProperty.call(gaugeContract, 'approved_to_deposit')) return [3 /*break*/, 3];
                        return [4 /*yield*/, gaugeContract.approved_to_deposit(curve_1.curve.constants.ALIASES.deposit_and_stake, curve_1.curve.signerAddress, curve_1.curve.constantOptions)];
                    case 2:
                        gaugeAllowance = _a.sent();
                        return [2 /*return*/, coinsAllowance && gaugeAllowance];
                    case 3: return [2 /*return*/, coinsAllowance];
                }
            });
        });
    };
    PoolTemplate.prototype.depositAndStakeWrappedApproveEstimateGas = function (amounts) {
        return __awaiter(this, void 0, void 0, function () {
            var approveCoinsGas, gaugeContract, gaugeAllowance, approveGaugeGas;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.gauge === ethers_1.ethers.constants.AddressZero) {
                            throw Error("depositAndStakeWrappedApprove method doesn't exist for pool ".concat(this.name, " (id: ").concat(this.name, "). There is no gauge"));
                        }
                        if (this.isFake)
                            throw Error("depositAndStakeWrappedApprove method doesn't exist for pool ".concat(this.name, " (id: ").concat(this.name, ")"));
                        return [4 /*yield*/, (0, utils_1.ensureAllowanceEstimateGas)(this.wrappedCoinAddresses, amounts, curve_1.curve.constants.ALIASES.deposit_and_stake)];
                    case 1:
                        approveCoinsGas = _a.sent();
                        gaugeContract = curve_1.curve.contracts[this.gauge].contract;
                        if (!Object.prototype.hasOwnProperty.call(gaugeContract, 'approved_to_deposit')) return [3 /*break*/, 4];
                        return [4 /*yield*/, gaugeContract.approved_to_deposit(curve_1.curve.constants.ALIASES.deposit_and_stake, curve_1.curve.signerAddress, curve_1.curve.constantOptions)];
                    case 2:
                        gaugeAllowance = _a.sent();
                        if (!!gaugeAllowance) return [3 /*break*/, 4];
                        return [4 /*yield*/, gaugeContract.estimateGas.set_approve_deposit(curve_1.curve.constants.ALIASES.deposit_and_stake, true, curve_1.curve.constantOptions)];
                    case 3:
                        approveGaugeGas = (_a.sent()).toNumber();
                        return [2 /*return*/, approveCoinsGas + approveGaugeGas];
                    case 4: return [2 /*return*/, approveCoinsGas];
                }
            });
        });
    };
    PoolTemplate.prototype.depositAndStakeWrappedApprove = function (amounts) {
        return __awaiter(this, void 0, void 0, function () {
            var approveCoinsTx, gaugeContract, gaugeAllowance, gasLimit, approveGaugeTx;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.gauge === ethers_1.ethers.constants.AddressZero) {
                            throw Error("depositAndStakeWrappedApprove method doesn't exist for pool ".concat(this.name, " (id: ").concat(this.name, "). There is no gauge"));
                        }
                        if (this.isFake)
                            throw Error("depositAndStakeWrappedApprove method doesn't exist for pool ".concat(this.name, " (id: ").concat(this.name, ")"));
                        return [4 /*yield*/, (0, utils_1.ensureAllowance)(this.wrappedCoinAddresses, amounts, curve_1.curve.constants.ALIASES.deposit_and_stake)];
                    case 1:
                        approveCoinsTx = _a.sent();
                        gaugeContract = curve_1.curve.contracts[this.gauge].contract;
                        if (!Object.prototype.hasOwnProperty.call(gaugeContract, 'approved_to_deposit')) return [3 /*break*/, 5];
                        return [4 /*yield*/, gaugeContract.approved_to_deposit(curve_1.curve.constants.ALIASES.deposit_and_stake, curve_1.curve.signerAddress, curve_1.curve.constantOptions)];
                    case 2:
                        gaugeAllowance = _a.sent();
                        if (!!gaugeAllowance) return [3 /*break*/, 5];
                        return [4 /*yield*/, gaugeContract.estimateGas.set_approve_deposit(curve_1.curve.constants.ALIASES.deposit_and_stake, true, curve_1.curve.constantOptions)];
                    case 3:
                        gasLimit = (_a.sent()).mul(130).div(100);
                        return [4 /*yield*/, gaugeContract.set_approve_deposit(curve_1.curve.constants.ALIASES.deposit_and_stake, true, __assign(__assign({}, curve_1.curve.options), { gasLimit: gasLimit }))];
                    case 4:
                        approveGaugeTx = (_a.sent()).hash;
                        return [2 /*return*/, __spreadArray(__spreadArray([], approveCoinsTx, true), [approveGaugeTx], false)];
                    case 5: return [2 /*return*/, approveCoinsTx];
                }
            });
        });
    };
    PoolTemplate.prototype.depositAndStakeWrappedEstimateGas = function (amounts) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.gauge === ethers_1.ethers.constants.AddressZero) {
                            throw Error("depositAndStakeWrapped method doesn't exist for pool ".concat(this.name, " (id: ").concat(this.name, "). There is no gauge"));
                        }
                        if (this.isFake)
                            throw Error("depositAndStakeWrapped method doesn't exist for pool ".concat(this.name, " (id: ").concat(this.name, ")"));
                        return [4 /*yield*/, this._depositAndStake(amounts, false, true)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    PoolTemplate.prototype.depositAndStakeWrapped = function (amounts) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.gauge === ethers_1.ethers.constants.AddressZero) {
                            throw Error("depositAndStakeWrapped method doesn't exist for pool ".concat(this.name, " (id: ").concat(this.name, "). There is no gauge"));
                        }
                        if (this.isFake)
                            throw Error("depositAndStakeWrapped method doesn't exist for pool ".concat(this.name, " (id: ").concat(this.name, ")"));
                        return [4 /*yield*/, this._depositAndStake(amounts, false, false)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    PoolTemplate.prototype._depositAndStake = function (amounts, isUnderlying, estimateGas) {
        return __awaiter(this, void 0, void 0, function () {
            var coinAddresses, coins, decimals, depositAddress, balances, _a, _c, _d, _e, _f, i, allowance, _g, _amounts, contract, useUnderlying, _minMintAmount, _h, _j, _k, _l, _m, ethIndex, value, i, _gas, gasLimit;
            return __generator(this, function (_o) {
                switch (_o.label) {
                    case 0:
                        coinAddresses = isUnderlying ? __spreadArray([], this.underlyingCoinAddresses, true) : __spreadArray([], this.wrappedCoinAddresses, true);
                        coins = isUnderlying ? this.underlyingCoins : this.wrappedCoinAddresses;
                        decimals = isUnderlying ? this.underlyingDecimals : this.wrappedDecimals;
                        depositAddress = isUnderlying ? this.zap || this.address : this.address;
                        if (amounts.length !== coinAddresses.length) {
                            throw Error("".concat(this.name, " pool has ").concat(coinAddresses.length, " coins (amounts provided for ").concat(amounts.length, ")"));
                        }
                        if (!isUnderlying) return [3 /*break*/, 2];
                        _d = (_c = Object).values;
                        return [4 /*yield*/, this.walletUnderlyingCoinBalances()];
                    case 1:
                        _a = _d.apply(_c, [_o.sent()]);
                        return [3 /*break*/, 4];
                    case 2:
                        _f = (_e = Object).values;
                        return [4 /*yield*/, this.walletWrappedCoinBalances()];
                    case 3:
                        _a = _f.apply(_e, [_o.sent()]);
                        _o.label = 4;
                    case 4:
                        balances = _a;
                        for (i = 0; i < balances.length; i++) {
                            if (Number(balances[i]) < Number(amounts[i])) {
                                throw Error("Not enough ".concat(coins[i], ". Actual: ").concat(balances[i], ", required: ").concat(amounts[i]));
                            }
                        }
                        if (!isUnderlying) return [3 /*break*/, 6];
                        return [4 /*yield*/, this.depositAndStakeIsApproved(amounts)];
                    case 5:
                        _g = _o.sent();
                        return [3 /*break*/, 8];
                    case 6: return [4 /*yield*/, this.depositAndStakeWrappedIsApproved(amounts)];
                    case 7:
                        _g = _o.sent();
                        _o.label = 8;
                    case 8:
                        allowance = _g;
                        if (estimateGas && !allowance) {
                            throw Error("Token allowance is needed to estimate gas");
                        }
                        if (!!estimateGas) return [3 /*break*/, 12];
                        if (!isUnderlying) return [3 /*break*/, 10];
                        return [4 /*yield*/, this.depositAndStakeApprove(amounts)];
                    case 9:
                        _o.sent();
                        return [3 /*break*/, 12];
                    case 10: return [4 /*yield*/, this.depositAndStakeWrappedApprove(amounts)];
                    case 11:
                        _o.sent();
                        _o.label = 12;
                    case 12:
                        _amounts = amounts.map(function (amount, i) { return (0, utils_1.parseUnits)(amount, decimals[i]); });
                        contract = curve_1.curve.contracts[curve_1.curve.constants.ALIASES.deposit_and_stake].contract;
                        useUnderlying = isUnderlying && (this.isLending || this.isCrypto) && !this.zap;
                        if (!isUnderlying) return [3 /*break*/, 14];
                        _k = (_j = ethers_1.ethers.utils).parseUnits;
                        return [4 /*yield*/, this.depositAndStakeExpected(amounts)];
                    case 13:
                        _h = _k.apply(_j, [_o.sent()]).mul(99).div(100);
                        return [3 /*break*/, 16];
                    case 14:
                        _m = (_l = ethers_1.ethers.utils).parseUnits;
                        return [4 /*yield*/, this.depositAndStakeWrappedExpected(amounts)];
                    case 15:
                        _h = _m.apply(_l, [_o.sent()]).mul(99).div(100);
                        _o.label = 16;
                    case 16:
                        _minMintAmount = _h;
                        ethIndex = (0, utils_1.getEthIndex)(coinAddresses);
                        value = _amounts[ethIndex] || ethers_1.ethers.BigNumber.from(0);
                        for (i = 0; i < 5; i++) {
                            coinAddresses[i] = coinAddresses[i] || ethers_1.ethers.constants.AddressZero;
                            _amounts[i] = _amounts[i] || ethers_1.ethers.BigNumber.from(0);
                        }
                        return [4 /*yield*/, contract.estimateGas.deposit_and_stake(depositAddress, this.lpToken, this.gauge, coins.length, coinAddresses, _amounts, _minMintAmount, useUnderlying, this.isMetaFactory && isUnderlying ? this.address : ethers_1.ethers.constants.AddressZero, __assign(__assign({}, curve_1.curve.constantOptions), { value: value }))];
                    case 17:
                        _gas = (_o.sent());
                        if (estimateGas)
                            return [2 /*return*/, _gas.toNumber()];
                        return [4 /*yield*/, curve_1.curve.updateFeeData()];
                    case 18:
                        _o.sent();
                        gasLimit = _gas.mul(200).div(100);
                        return [4 /*yield*/, contract.deposit_and_stake(depositAddress, this.lpToken, this.gauge, coins.length, coinAddresses, _amounts, _minMintAmount, useUnderlying, this.isMetaFactory && isUnderlying ? this.address : ethers_1.ethers.constants.AddressZero, __assign(__assign({}, curve_1.curve.options), { gasLimit: gasLimit, value: value }))];
                    case 19: return [2 /*return*/, (_o.sent()).hash];
                }
            });
        });
    };
    // ---------------- WITHDRAW ----------------
    // OVERRIDE
    PoolTemplate.prototype.withdrawExpected = function (lpTokenAmount) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                throw Error("withdrawExpected method doesn't exist for pool ".concat(this.name, " (id: ").concat(this.name, ")"));
            });
        });
    };
    PoolTemplate.prototype.withdrawIsApproved = function (lpTokenAmount) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.zap)
                            return [2 /*return*/, true];
                        return [4 /*yield*/, (0, utils_1.hasAllowance)([this.lpToken], [lpTokenAmount], curve_1.curve.signerAddress, this.zap)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    PoolTemplate.prototype.withdrawApproveEstimateGas = function (lpTokenAmount) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.zap)
                            return [2 /*return*/, 0];
                        return [4 /*yield*/, (0, utils_1.ensureAllowanceEstimateGas)([this.lpToken], [lpTokenAmount], this.zap)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    PoolTemplate.prototype.withdrawApprove = function (lpTokenAmount) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.zap)
                            return [2 /*return*/, []];
                        return [4 /*yield*/, (0, utils_1.ensureAllowance)([this.lpToken], [lpTokenAmount], this.zap)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    // OVERRIDE
    PoolTemplate.prototype.withdrawEstimateGas = function (lpTokenAmount) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                throw Error("withdraw method doesn't exist for pool ".concat(this.name, " (id: ").concat(this.name, ")"));
            });
        });
    };
    // OVERRIDE
    PoolTemplate.prototype.withdraw = function (lpTokenAmount, slippage) {
        if (slippage === void 0) { slippage = 0.5; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                throw Error("withdraw method doesn't exist for pool ".concat(this.name, " (id: ").concat(this.name, ")"));
            });
        });
    };
    // ---------------- WITHDRAW WRAPPED ----------------
    // OVERRIDE
    PoolTemplate.prototype.withdrawWrappedExpected = function (lpTokenAmount) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                throw Error("withdrawWrappedExpected method doesn't exist for pool ".concat(this.name, " (id: ").concat(this.name, ")"));
            });
        });
    };
    // OVERRIDE
    PoolTemplate.prototype.withdrawWrappedEstimateGas = function (lpTokenAmount) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                throw Error("withdrawWrapped method doesn't exist for pool ".concat(this.name, " (id: ").concat(this.name, ")"));
            });
        });
    };
    // OVERRIDE
    PoolTemplate.prototype.withdrawWrapped = function (lpTokenAmount, slippage) {
        if (slippage === void 0) { slippage = 0.5; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                throw Error("withdrawWrapped method doesn't exist for pool ".concat(this.name, " (id: ").concat(this.name, ")"));
            });
        });
    };
    // ---------------- WITHDRAW IMBALANCE ----------------
    PoolTemplate.prototype.withdrawImbalanceExpected = function (amounts) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.isCrypto)
                            throw Error("withdrawImbalanceExpected method doesn't exist for pool ".concat(this.name, " (id: ").concat(this.name, ")"));
                        return [4 /*yield*/, this.calcLpTokenAmount(amounts, false)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    PoolTemplate.prototype.withdrawImbalanceBonus = function (amounts) {
        return __awaiter(this, void 0, void 0, function () {
            var totalAmount, expected, _a;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        if (this.isCrypto)
                            throw Error("withdrawImbalanceBonus method doesn't exist for pool ".concat(this.name, " (id: ").concat(this.name, ")"));
                        totalAmount = amounts.map(utils_1.checkNumber).map(Number).reduce(function (a, b) { return a + b; });
                        _a = Number;
                        return [4 /*yield*/, this.withdrawImbalanceExpected(amounts)];
                    case 1:
                        expected = _a.apply(void 0, [_c.sent()]);
                        return [4 /*yield*/, this._withdrawBonus(totalAmount, expected)];
                    case 2: return [2 /*return*/, _c.sent()];
                }
            });
        });
    };
    PoolTemplate.prototype.withdrawImbalanceIsApproved = function (amounts) {
        return __awaiter(this, void 0, void 0, function () {
            var _amounts, _maxBurnAmount;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.isCrypto)
                            throw Error("withdrawImbalanceIsApproved method doesn't exist for pool ".concat(this.name, " (id: ").concat(this.name, ")"));
                        if (!this.zap) return [3 /*break*/, 3];
                        _amounts = amounts.map(function (amount, i) { return (0, utils_1.parseUnits)(amount, _this.underlyingDecimals[i]); });
                        return [4 /*yield*/, this._calcLpTokenAmount(_amounts, false)];
                    case 1:
                        _maxBurnAmount = (_a.sent()).mul(101).div(100);
                        return [4 /*yield*/, (0, utils_1.hasAllowance)([this.lpToken], [ethers_1.ethers.utils.formatUnits(_maxBurnAmount, 18)], curve_1.curve.signerAddress, this.zap)];
                    case 2: return [2 /*return*/, _a.sent()];
                    case 3: return [2 /*return*/, true];
                }
            });
        });
    };
    PoolTemplate.prototype.withdrawImbalanceApproveEstimateGas = function (amounts) {
        return __awaiter(this, void 0, void 0, function () {
            var _amounts, _maxBurnAmount;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.isCrypto)
                            throw Error("withdrawImbalanceApprove method doesn't exist for pool ".concat(this.name, " (id: ").concat(this.name, ")"));
                        if (!this.zap) return [3 /*break*/, 3];
                        _amounts = amounts.map(function (amount, i) { return (0, utils_1.parseUnits)(amount, _this.underlyingDecimals[i]); });
                        return [4 /*yield*/, this._calcLpTokenAmount(_amounts, false)];
                    case 1:
                        _maxBurnAmount = (_a.sent()).mul(101).div(100);
                        return [4 /*yield*/, (0, utils_1.ensureAllowanceEstimateGas)([this.lpToken], [ethers_1.ethers.utils.formatUnits(_maxBurnAmount, 18)], this.zap)];
                    case 2: return [2 /*return*/, _a.sent()];
                    case 3: return [2 /*return*/, 0];
                }
            });
        });
    };
    PoolTemplate.prototype.withdrawImbalanceApprove = function (amounts) {
        return __awaiter(this, void 0, void 0, function () {
            var _amounts, _maxBurnAmount;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.isCrypto)
                            throw Error("withdrawImbalanceApprove method doesn't exist for pool ".concat(this.name, " (id: ").concat(this.name, ")"));
                        if (!this.zap) return [3 /*break*/, 3];
                        _amounts = amounts.map(function (amount, i) { return (0, utils_1.parseUnits)(amount, _this.underlyingDecimals[i]); });
                        return [4 /*yield*/, this._calcLpTokenAmount(_amounts, false)];
                    case 1:
                        _maxBurnAmount = (_a.sent()).mul(101).div(100);
                        return [4 /*yield*/, (0, utils_1.ensureAllowance)([this.lpToken], [ethers_1.ethers.utils.formatUnits(_maxBurnAmount, 18)], this.zap)];
                    case 2: return [2 /*return*/, _a.sent()];
                    case 3: return [2 /*return*/, []];
                }
            });
        });
    };
    // OVERRIDE
    PoolTemplate.prototype.withdrawImbalanceEstimateGas = function (amounts) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                throw Error("withdrawImbalance method doesn't exist for pool ".concat(this.name, " (id: ").concat(this.name, ")"));
            });
        });
    };
    // OVERRIDE
    PoolTemplate.prototype.withdrawImbalance = function (amounts, slippage) {
        if (slippage === void 0) { slippage = 0.5; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                throw Error("withdrawImbalance method doesn't exist for pool ".concat(this.name, " (id: ").concat(this.name, ")"));
            });
        });
    };
    // ---------------- WITHDRAW IMBALANCE WRAPPED ----------------
    PoolTemplate.prototype.withdrawImbalanceWrappedExpected = function (amounts) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.isCrypto)
                            throw Error("withdrawImbalanceWrappedExpected method doesn't exist for pool ".concat(this.name, " (id: ").concat(this.name, ")"));
                        return [4 /*yield*/, this.calcLpTokenAmountWrapped(amounts, false)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    PoolTemplate.prototype.withdrawImbalanceWrappedBonus = function (amounts) {
        return __awaiter(this, void 0, void 0, function () {
            var totalAmount, expected, _a;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        if (this.isCrypto)
                            throw Error("withdrawImbalanceWrappedBonus method doesn't exist for pool ".concat(this.name, " (id: ").concat(this.name, ")"));
                        totalAmount = amounts.map(utils_1.checkNumber).map(Number).reduce(function (a, b) { return a + b; });
                        _a = Number;
                        return [4 /*yield*/, this.withdrawImbalanceWrappedExpected(amounts)];
                    case 1:
                        expected = _a.apply(void 0, [_c.sent()]);
                        return [4 /*yield*/, this._withdrawBonus(totalAmount, expected, false)];
                    case 2: return [2 /*return*/, _c.sent()];
                }
            });
        });
    };
    // OVERRIDE
    PoolTemplate.prototype.withdrawImbalanceWrappedEstimateGas = function (amounts) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                throw Error("withdrawImbalanceWrapped method doesn't exist for pool ".concat(this.name, " (id: ").concat(this.name, ")"));
            });
        });
    };
    // OVERRIDE
    PoolTemplate.prototype.withdrawImbalanceWrapped = function (amounts, slippage) {
        if (slippage === void 0) { slippage = 0.5; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                throw Error("withdrawImbalanceWrapped method doesn't exist for pool ".concat(this.name, " (id: ").concat(this.name, ")"));
            });
        });
    };
    // ---------------- WITHDRAW ONE COIN ----------------
    // OVERRIDE
    PoolTemplate.prototype._withdrawOneCoinExpected = function (_lpTokenAmount, i) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                throw Error("withdrawOneCoinExpected method doesn't exist for pool ".concat(this.name, " (id: ").concat(this.name, ")"));
            });
        });
    };
    PoolTemplate.prototype.withdrawOneCoinExpected = function (lpTokenAmount, coin) {
        return __awaiter(this, void 0, void 0, function () {
            var i, _lpTokenAmount, _expected;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        i = this._getCoinIdx(coin);
                        _lpTokenAmount = (0, utils_1.parseUnits)(lpTokenAmount);
                        return [4 /*yield*/, this._withdrawOneCoinExpected(_lpTokenAmount, i)];
                    case 1:
                        _expected = _a.sent();
                        return [2 /*return*/, ethers_1.ethers.utils.formatUnits(_expected, this.underlyingDecimals[i])];
                }
            });
        });
    };
    PoolTemplate.prototype.withdrawOneCoinBonus = function (lpTokenAmount, coin) {
        return __awaiter(this, void 0, void 0, function () {
            var totalAmount, _a, coinPrice;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _a = Number;
                        return [4 /*yield*/, this.withdrawOneCoinExpected(lpTokenAmount, coin)];
                    case 1:
                        totalAmount = _a.apply(void 0, [_c.sent()]);
                        if (!this.isCrypto) return [3 /*break*/, 4];
                        return [4 /*yield*/, this._underlyingPrices()];
                    case 2:
                        coinPrice = (_c.sent())[this._getCoinIdx(coin)];
                        return [4 /*yield*/, this._withdrawCryptoBonus(totalAmount * coinPrice, Number(lpTokenAmount))];
                    case 3: return [2 /*return*/, _c.sent()];
                    case 4: return [4 /*yield*/, this._withdrawBonus(totalAmount, Number(lpTokenAmount))];
                    case 5: return [2 /*return*/, _c.sent()];
                }
            });
        });
    };
    PoolTemplate.prototype.withdrawOneCoinIsApproved = function (lpTokenAmount) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.zap)
                            return [2 /*return*/, true];
                        return [4 /*yield*/, (0, utils_1.hasAllowance)([this.lpToken], [lpTokenAmount], curve_1.curve.signerAddress, this.zap)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    PoolTemplate.prototype.withdrawOneCoinApproveEstimateGas = function (lpTokenAmount) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.zap)
                            return [2 /*return*/, 0];
                        return [4 /*yield*/, (0, utils_1.ensureAllowanceEstimateGas)([this.lpToken], [lpTokenAmount], this.zap)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    PoolTemplate.prototype.withdrawOneCoinApprove = function (lpTokenAmount) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.zap)
                            return [2 /*return*/, []];
                        return [4 /*yield*/, (0, utils_1.ensureAllowance)([this.lpToken], [lpTokenAmount], this.zap)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    // OVERRIDE
    PoolTemplate.prototype.withdrawOneCoinEstimateGas = function (lpTokenAmount, coin) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                throw Error("withdrawOneCoin method doesn't exist for pool ".concat(this.name, " (id: ").concat(this.name, ")"));
            });
        });
    };
    // OVERRIDE
    PoolTemplate.prototype.withdrawOneCoin = function (lpTokenAmount, coin, slippage) {
        if (slippage === void 0) { slippage = 0.5; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                throw Error("withdrawOneCoin method doesn't exist for pool ".concat(this.name, " (id: ").concat(this.name, ")"));
            });
        });
    };
    // ---------------- WITHDRAW ONE COIN WRAPPED ----------------
    // OVERRIDE
    PoolTemplate.prototype._withdrawOneCoinWrappedExpected = function (_lpTokenAmount, i) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                throw Error("withdrawOneCoinWrappedExpected method doesn't exist for pool ".concat(this.name, " (id: ").concat(this.name, ")"));
            });
        });
    };
    PoolTemplate.prototype.withdrawOneCoinWrappedExpected = function (lpTokenAmount, coin) {
        return __awaiter(this, void 0, void 0, function () {
            var i, _lpTokenAmount, _expected;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        i = this._getCoinIdx(coin, false);
                        _lpTokenAmount = (0, utils_1.parseUnits)(lpTokenAmount);
                        return [4 /*yield*/, this._withdrawOneCoinWrappedExpected(_lpTokenAmount, i)];
                    case 1:
                        _expected = _a.sent();
                        return [2 /*return*/, ethers_1.ethers.utils.formatUnits(_expected, this.wrappedDecimals[i])];
                }
            });
        });
    };
    PoolTemplate.prototype.withdrawOneCoinWrappedBonus = function (lpTokenAmount, coin) {
        return __awaiter(this, void 0, void 0, function () {
            var totalAmount, _a, coinPrice;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        if (this.isFake) {
                            throw Error("".concat(this.name, " pool doesn't have this method"));
                        }
                        _a = Number;
                        return [4 /*yield*/, this.withdrawOneCoinWrappedExpected(lpTokenAmount, coin)];
                    case 1:
                        totalAmount = _a.apply(void 0, [_c.sent()]);
                        if (!this.isCrypto) return [3 /*break*/, 4];
                        return [4 /*yield*/, this._underlyingPrices()];
                    case 2:
                        coinPrice = (_c.sent())[this._getCoinIdx(coin, false)];
                        return [4 /*yield*/, this._withdrawCryptoBonus(totalAmount * coinPrice, Number(lpTokenAmount))];
                    case 3: return [2 /*return*/, _c.sent()];
                    case 4: return [4 /*yield*/, this._withdrawBonus(totalAmount, Number(lpTokenAmount), false)];
                    case 5: return [2 /*return*/, _c.sent()];
                }
            });
        });
    };
    // OVERRIDE
    PoolTemplate.prototype.withdrawOneCoinWrappedEstimateGas = function (lpTokenAmount, coin) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                throw Error("withdrawOneCoinWrapped method doesn't exist for pool ".concat(this.name, " (id: ").concat(this.name, ")"));
            });
        });
    };
    // OVERRIDE
    PoolTemplate.prototype.withdrawOneCoinWrapped = function (lpTokenAmount, coin, slippage) {
        if (slippage === void 0) { slippage = 0.5; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                throw Error("withdrawOneCoinWrapped method doesn't exist for pool ".concat(this.name, " (id: ").concat(this.name, ")"));
            });
        });
    };
    // ---------------- WALLET BALANCES ----------------
    PoolTemplate.prototype.walletBalances = function () {
        var addresses = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            addresses[_i] = arguments[_i];
        }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(this.gauge === ethers_1.ethers.constants.AddressZero)) return [3 /*break*/, 2];
                        return [4 /*yield*/, this._balances.apply(this, __spreadArray([__spreadArray(__spreadArray(['lpToken'], this.underlyingCoinAddresses, true), this.wrappedCoinAddresses, true), __spreadArray(__spreadArray([this.lpToken], this.underlyingCoinAddresses, true), this.wrappedCoinAddresses, true)], addresses, false))];
                    case 1: return [2 /*return*/, _a.sent()];
                    case 2: return [4 /*yield*/, this._balances.apply(this, __spreadArray([__spreadArray(__spreadArray(['lpToken', 'gauge'], this.underlyingCoinAddresses, true), this.wrappedCoinAddresses, true), __spreadArray(__spreadArray([this.lpToken, this.gauge], this.underlyingCoinAddresses, true), this.wrappedCoinAddresses, true)], addresses, false))];
                    case 3: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    PoolTemplate.prototype.walletLpTokenBalances = function () {
        var addresses = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            addresses[_i] = arguments[_i];
        }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(this.gauge === ethers_1.ethers.constants.AddressZero)) return [3 /*break*/, 2];
                        return [4 /*yield*/, this._balances.apply(this, __spreadArray([['lpToken'], [this.lpToken]], addresses, false))];
                    case 1: return [2 /*return*/, _a.sent()];
                    case 2: return [4 /*yield*/, this._balances.apply(this, __spreadArray([['lpToken', 'gauge'], [this.lpToken, this.gauge]], addresses, false))];
                    case 3: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    PoolTemplate.prototype.walletUnderlyingCoinBalances = function () {
        var addresses = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            addresses[_i] = arguments[_i];
        }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._balances.apply(this, __spreadArray([this.underlyingCoinAddresses, this.underlyingCoinAddresses], addresses, false))];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    PoolTemplate.prototype.walletWrappedCoinBalances = function () {
        var addresses = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            addresses[_i] = arguments[_i];
        }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._balances.apply(this, __spreadArray([this.wrappedCoinAddresses, this.wrappedCoinAddresses], addresses, false))];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    PoolTemplate.prototype.walletAllCoinBalances = function () {
        var addresses = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            addresses[_i] = arguments[_i];
        }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._balances.apply(this, __spreadArray([__spreadArray(__spreadArray([], this.underlyingCoinAddresses, true), this.wrappedCoinAddresses, true), __spreadArray(__spreadArray([], this.underlyingCoinAddresses, true), this.wrappedCoinAddresses, true)], addresses, false))];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    // ---------------- SWAP ----------------
    PoolTemplate.prototype._swapExpected = function (i, j, _amount) {
        return __awaiter(this, void 0, void 0, function () {
            var contractAddress, contract;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        contractAddress = this.isCrypto && this.isMeta ? this.zap : this.address;
                        contract = curve_1.curve.contracts[contractAddress].contract;
                        if (!Object.prototype.hasOwnProperty.call(contract, 'get_dy_underlying')) return [3 /*break*/, 2];
                        return [4 /*yield*/, contract.get_dy_underlying(i, j, _amount, curve_1.curve.constantOptions)];
                    case 1: return [2 /*return*/, _a.sent()];
                    case 2: return [4 /*yield*/, contract.get_dy(i, j, _amount, curve_1.curve.constantOptions)];
                    case 3: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    PoolTemplate.prototype.swapExpected = function (inputCoin, outputCoin, amount) {
        return __awaiter(this, void 0, void 0, function () {
            var i, j, _amount, _expected;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        i = this._getCoinIdx(inputCoin);
                        j = this._getCoinIdx(outputCoin);
                        _amount = (0, utils_1.parseUnits)(amount, this.underlyingDecimals[i]);
                        return [4 /*yield*/, this._swapExpected(i, j, _amount)];
                    case 1:
                        _expected = _a.sent();
                        return [2 /*return*/, ethers_1.ethers.utils.formatUnits(_expected, this.underlyingDecimals[j])];
                }
            });
        });
    };
    PoolTemplate.prototype.swapPriceImpact = function (inputCoin, outputCoin, amount) {
        return __awaiter(this, void 0, void 0, function () {
            var i, j, _a, inputCoinDecimals, outputCoinDecimals, _amount, _output, target, amountIntBN, outputIntBN, k, smallAmountIntBN, _smallAmount, _smallOutput, amountBN, outputBN, smallAmountBN, smallOutputBN, rateBN, smallRateBN, slippageBN;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        i = this._getCoinIdx(inputCoin);
                        j = this._getCoinIdx(outputCoin);
                        _a = [this.underlyingDecimals[i], this.underlyingDecimals[j]], inputCoinDecimals = _a[0], outputCoinDecimals = _a[1];
                        _amount = (0, utils_1.parseUnits)(amount, inputCoinDecimals);
                        return [4 /*yield*/, this._swapExpected(i, j, _amount)];
                    case 1:
                        _output = _c.sent();
                        target = (0, utils_1.BN)(1000000);
                        amountIntBN = (0, utils_1.BN)(amount).times(Math.pow(10, inputCoinDecimals));
                        outputIntBN = (0, utils_1.toBN)(_output, 0);
                        k = bignumber_js_1.default.min(bignumber_js_1.default.max(target.div(amountIntBN), target.div(outputIntBN)), 0.2);
                        smallAmountIntBN = bignumber_js_1.default.min(amountIntBN.times(k), (0, utils_1.BN)(Math.pow(10, inputCoinDecimals)));
                        if (smallAmountIntBN.toFixed(0) === '0')
                            return [2 /*return*/, '0'];
                        _smallAmount = (0, utils_1.fromBN)(smallAmountIntBN.div(Math.pow(10, inputCoinDecimals)), inputCoinDecimals);
                        return [4 /*yield*/, this._swapExpected(i, j, _smallAmount)];
                    case 2:
                        _smallOutput = _c.sent();
                        amountBN = (0, utils_1.BN)(amount);
                        outputBN = (0, utils_1.toBN)(_output, outputCoinDecimals);
                        smallAmountBN = (0, utils_1.toBN)(_smallAmount, inputCoinDecimals);
                        smallOutputBN = (0, utils_1.toBN)(_smallOutput, outputCoinDecimals);
                        rateBN = outputBN.div(amountBN);
                        smallRateBN = smallOutputBN.div(smallAmountBN);
                        slippageBN = (0, utils_1.BN)(1).minus(rateBN.div(smallRateBN)).times(100);
                        return [2 /*return*/, (0, utils_1._cutZeros)(slippageBN.toFixed(6)).replace('-', '')];
                }
            });
        });
    };
    PoolTemplate.prototype._swapContractAddress = function () {
        return (this.isCrypto && this.isMeta) || (curve_1.curve.chainId === 137 && this.isMetaFactory) ? this.zap : this.address;
    };
    PoolTemplate.prototype.swapIsApproved = function (inputCoin, amount) {
        return __awaiter(this, void 0, void 0, function () {
            var contractAddress, i;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        contractAddress = this._swapContractAddress();
                        i = this._getCoinIdx(inputCoin);
                        return [4 /*yield*/, (0, utils_1.hasAllowance)([this.underlyingCoinAddresses[i]], [amount], curve_1.curve.signerAddress, contractAddress)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    PoolTemplate.prototype.swapApproveEstimateGas = function (inputCoin, amount) {
        return __awaiter(this, void 0, void 0, function () {
            var contractAddress, i;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        contractAddress = this._swapContractAddress();
                        i = this._getCoinIdx(inputCoin);
                        return [4 /*yield*/, (0, utils_1.ensureAllowanceEstimateGas)([this.underlyingCoinAddresses[i]], [amount], contractAddress)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    PoolTemplate.prototype.swapApprove = function (inputCoin, amount) {
        return __awaiter(this, void 0, void 0, function () {
            var contractAddress, i;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        contractAddress = this._swapContractAddress();
                        i = this._getCoinIdx(inputCoin);
                        return [4 /*yield*/, (0, utils_1.ensureAllowance)([this.underlyingCoinAddresses[i]], [amount], contractAddress)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    // OVERRIDE
    PoolTemplate.prototype.swapEstimateGas = function (inputCoin, outputCoin, amount) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                throw Error("swap method doesn't exist for pool ".concat(this.name, " (id: ").concat(this.name, ")"));
            });
        });
    };
    // OVERRIDE
    PoolTemplate.prototype.swap = function (inputCoin, outputCoin, amount, slippage) {
        if (slippage === void 0) { slippage = 0.5; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                throw Error("swap method doesn't exist for pool ".concat(this.name, " (id: ").concat(this.name, ")"));
            });
        });
    };
    // ---------------- SWAP WRAPPED ----------------
    PoolTemplate.prototype._swapWrappedExpected = function (i, j, _amount) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, curve_1.curve.contracts[this.address].contract.get_dy(i, j, _amount, curve_1.curve.constantOptions)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    // OVERRIDE
    PoolTemplate.prototype.swapWrappedExpected = function (inputCoin, outputCoin, amount) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                throw Error("swapWrappedExpected method doesn't exist for pool ".concat(this.name, " (id: ").concat(this.name, ")"));
            });
        });
    };
    PoolTemplate.prototype.swapWrappedPriceImpact = function (inputCoin, outputCoin, amount) {
        return __awaiter(this, void 0, void 0, function () {
            var i, j, _a, inputCoinDecimals, outputCoinDecimals, _amount, _output, target, amountIntBN, outputIntBN, k, smallAmountIntBN, _smallAmount, _smallOutput, amountBN, outputBN, smallAmountBN, smallOutputBN, rateBN, smallRateBN, slippageBN;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        if (this.isPlain || this.isFake) {
                            throw Error("swapWrappedPriceImpact method doesn't exist for pool ".concat(this.name, " (id: ").concat(this.name, ")"));
                        }
                        i = this._getCoinIdx(inputCoin, false);
                        j = this._getCoinIdx(outputCoin, false);
                        _a = [this.wrappedDecimals[i], this.wrappedDecimals[j]], inputCoinDecimals = _a[0], outputCoinDecimals = _a[1];
                        _amount = (0, utils_1.parseUnits)(amount, inputCoinDecimals);
                        return [4 /*yield*/, this._swapWrappedExpected(i, j, _amount)];
                    case 1:
                        _output = _c.sent();
                        target = (0, utils_1.BN)(1000000);
                        amountIntBN = (0, utils_1.BN)(amount).times(Math.pow(10, inputCoinDecimals));
                        outputIntBN = (0, utils_1.toBN)(_output, 0);
                        k = bignumber_js_1.default.min(bignumber_js_1.default.max(target.div(amountIntBN), target.div(outputIntBN)), 0.2);
                        smallAmountIntBN = bignumber_js_1.default.min(amountIntBN.times(k), (0, utils_1.BN)(Math.pow(10, inputCoinDecimals)));
                        if (smallAmountIntBN.toFixed(0) === '0')
                            return [2 /*return*/, '0'];
                        _smallAmount = (0, utils_1.fromBN)(smallAmountIntBN.div(Math.pow(10, inputCoinDecimals)), inputCoinDecimals);
                        return [4 /*yield*/, this._swapWrappedExpected(i, j, _smallAmount)];
                    case 2:
                        _smallOutput = _c.sent();
                        amountBN = (0, utils_1.BN)(amount);
                        outputBN = (0, utils_1.toBN)(_output, outputCoinDecimals);
                        smallAmountBN = (0, utils_1.toBN)(_smallAmount, inputCoinDecimals);
                        smallOutputBN = (0, utils_1.toBN)(_smallOutput, outputCoinDecimals);
                        rateBN = outputBN.div(amountBN);
                        smallRateBN = smallOutputBN.div(smallAmountBN);
                        slippageBN = (0, utils_1.BN)(1).minus(rateBN.div(smallRateBN)).times(100);
                        return [2 /*return*/, (0, utils_1._cutZeros)(slippageBN.toFixed(6)).replace('-', '')];
                }
            });
        });
    };
    // OVERRIDE
    PoolTemplate.prototype.swapWrappedIsApproved = function (inputCoin, amount) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                throw Error("swapWrappedIsApproved method doesn't exist for pool ".concat(this.name, " (id: ").concat(this.name, ")"));
            });
        });
    };
    // OVERRIDE
    PoolTemplate.prototype.swapWrappedApproveEstimateGas = function (inputCoin, amount) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                throw Error("swapWrappedApprove method doesn't exist for pool ".concat(this.name, " (id: ").concat(this.name, ")"));
            });
        });
    };
    // OVERRIDE
    PoolTemplate.prototype.swapWrappedApprove = function (inputCoin, amount) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                throw Error("swapWrappedApprove method doesn't exist for pool ".concat(this.name, " (id: ").concat(this.name, ")"));
            });
        });
    };
    // OVERRIDE
    PoolTemplate.prototype.swapWrappedEstimateGas = function (inputCoin, outputCoin, amount) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                throw Error("swapWrapped method doesn't exist for pool ".concat(this.name, " (id: ").concat(this.name, ")"));
            });
        });
    };
    // OVERRIDE
    PoolTemplate.prototype.swapWrapped = function (inputCoin, outputCoin, amount, slippage) {
        if (slippage === void 0) { slippage = 0.5; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                throw Error("swapWrapped method doesn't exist for pool ".concat(this.name, " (id: ").concat(this.name, ")"));
            });
        });
    };
    return PoolTemplate;
}());
exports.PoolTemplate = PoolTemplate;
