"use strict";
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var abi_coder_1 = __importDefault(require("abi-coder"));
var Abi = /** @class */ (function () {
    function Abi() {
    }
    Object.defineProperty(Abi, "encode", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (name, jsonInputs, params) {
            var inputs = backfillParamNames(jsonInputs);
            var abi = [
                {
                    type: 'function',
                    name: name,
                    inputs: inputs,
                },
            ];
            var coder = new abi_coder_1.default(abi);
            var valueMap = Object.fromEntries(inputs.map(function (input, index) { return [input.name, params[index]]; }));
            return coder.encodeFunction(name, valueMap);
        }
    });
    Object.defineProperty(Abi, "encodeConstructor", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (jsonInputs, params) {
            var inputs = backfillParamNames(jsonInputs);
            var abi = [
                {
                    type: 'constructor',
                    inputs: inputs,
                },
            ];
            var coder = new abi_coder_1.default(abi);
            var valueMap = Object.fromEntries(inputs.map(function (input, index) { return [input.name, params[index]]; }));
            return coder.encodeConstructor(valueMap);
        }
    });
    Object.defineProperty(Abi, "decode", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (name, jsonOutputs, data) {
            var outputs = backfillParamNames(jsonOutputs);
            var abi = [
                {
                    type: 'function',
                    name: name,
                    outputs: outputs,
                },
            ];
            var coder = new abi_coder_1.default(abi);
            var functionOutput = coder.decodeFunctionOutput(name, data);
            return outputs.map(function (output) { return functionOutput.values[output.name || '']; });
        }
    });
    return Abi;
}());
// ABI doesn't enforce to specify param names
// However, abi-coder requires names to parse the params.
// Therefore, we "patch" the ABI by assigning a unique param names.
function backfillParamNames(jsonParams) {
    var names = new (Set.bind.apply(Set, __spreadArray([void 0], jsonParams.map(function (param) { return param.name; }), false)))();
    return jsonParams.map(function (param) {
        var originalName = param.name, indexed = param.indexed, type = param.type, components = param.components;
        var name = originalName ? originalName : generateUniqueName(names);
        names.add(name);
        return {
            name: name,
            indexed: indexed,
            type: type,
            components: components,
        };
    });
}
function generateUniqueName(names) {
    var i = 0;
    while (names.has(i.toString())) {
        i++;
    }
    return i.toString();
}
exports.default = Abi;
//# sourceMappingURL=abi.js.map